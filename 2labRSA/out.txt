<!--
============================================================================================================================================
C:\Users\blazego\source\repos\2labRSA\2labRSA.csproj
============================================================================================================================================
-->
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')">

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
    <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonProps>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonProps>
    <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
  </PropertyGroup>
  <!--
      Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
      they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''" xmlns="">
    <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
    <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')">

C:\Users\blazego\source\repos\Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <AvaloniaVersion>11.1.0</AvaloniaVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''" />-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
        $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props

      Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
      management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup xmlns="">
    <!--
        The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
        in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
    -->
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
    <!--
        Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
        defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
        it needs to be made absolute based on the project directory.
    -->
    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionProps
    -->
    <ImportProjectExtensionProps Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionProps)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionProps>
    <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
    <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />-->
  <!--
      Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
      This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
      the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.

      Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
      so we have to have a slightly different directory name to hold extensions.
  -->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <PropertyGroup xmlns="">
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)')" />-->
  <!-- This is used to determine whether Microsoft.Common.targets needs to import
      Microsoft.Common.props itself, or whether it has been imported previously,
      e.g. by the project itself. -->
  <PropertyGroup xmlns="">
    <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <Configuration Condition=" '$(Configuration)' == '' and '$(DefaultProjectConfiguration)' != '' ">$(DefaultProjectConfiguration)</Configuration>
    <Platform Condition=" '$(Platform)' == '' and '$(DefaultProjectPlatform)' != '' ">$(DefaultProjectPlatform)</Platform>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <WMSJSProject Condition="'$(WMSJSProject)' == ''">WJProject</WMSJSProject>
    <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--
      Import NuGet.props file.
  -->
  <PropertyGroup xmlns="">
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPropsFile)" Condition="Exists('$(NuGetPropsFile)')">

C:\Program Files\dotnet\sdk\9.0.200\NuGet.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
      Import 'Directory.Packages.props' which will contain centralized packages for all the projects and solutions under
      the directory in which the file is present. This is similar to 'Directory.Build.props/targets' logic which is present
      in the common props/targets which serve a similar purpose.
  -->
  <PropertyGroup xmlns="">
    <ImportDirectoryPackagesProps Condition="'$(ImportDirectoryPackagesProps)' == ''">true</ImportDirectoryPackagesProps>
  </PropertyGroup>
  <!--
      Determine the path to the 'Directory.Packages.props' file, if the user did not disable $(ImportDirectoryPackagesProps) and
      they did not already specify an absolute path to use via $(DirectoryPackagesPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' == ''" xmlns="">
    <_DirectoryPackagesPropsFile Condition="'$(_DirectoryPackagesPropsFile)' == ''">Directory.Packages.props</_DirectoryPackagesPropsFile>
    <_DirectoryPackagesPropsBasePath Condition="'$(_DirectoryPackagesPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', '$(_DirectoryPackagesPropsFile)'))</_DirectoryPackagesPropsBasePath>
    <DirectoryPackagesPropsPath Condition="'$(_DirectoryPackagesPropsBasePath)' != '' and '$(_DirectoryPackagesPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryPackagesPropsBasePath)', '$(_DirectoryPackagesPropsFile)'))</DirectoryPackagesPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(DirectoryPackagesPropsPath)" Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" />-->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" xmlns="">
    <CentralPackageVersionsFileImported>true</CentralPackageVersionsFileImported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' " xmlns="">
    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\blazego\source\repos\2labRSA\2labRSA.csproj
============================================================================================================================================
-->
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{FFC0070B-FC8F-4727-B844-A6F52BD6B6B0}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>_2labRSA</RootNamespace>
    <AssemblyName>2labRSA</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Numerics" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <Choose xmlns="">
    <When Condition="'$(IsCrossTargetingBuild)' == 'true'">
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CrossTargeting.targets</CSharpTargetsPath>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CurrentVersion.targets</CSharpTargetsPath>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Managed.Before.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported before the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
      We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
      and there is no current target framework being built individually. In that case, a multitargeting
      project file like Microsoft.<language>.CrossTargeting.targets gets imported.
  -->
  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''" xmlns="">
    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(CSharpTargetsPath)">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCSharpTargets>
    <ImportByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportByWildcardAfterMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <PropertyGroup xmlns="">
    <CustomBeforeMicrosoftCSharpTargets Condition="'$(CustomBeforeMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.CSharp.targets</CustomBeforeMicrosoftCSharpTargets>
    <CustomAfterMicrosoftCSharpTargets Condition="'$(CustomAfterMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.CSharp.targets</CustomAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCSharpTargets)" Condition="'$(CustomBeforeMicrosoftCSharpTargets)' != '' and Exists('$(CustomBeforeMicrosoftCSharpTargets)')" />-->
  <PropertyGroup xmlns="">
    <DefaultLanguageSourceExtension>.cs</DefaultLanguageSourceExtension>
    <Language>C#</Language>
    <TargetRuntime>Managed</TargetRuntime>
    <AlwaysUseNumericalSuffixInItemNames>true</AlwaysUseNumericalSuffixInItemNames>
    <DefineCommonItemSchemas Condition=" '$(DefineCommonItemSchemas)' == '' ">true</DefineCommonItemSchemas>
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">true</DefineCommonReferenceSchemas>
    <DefineCommonCapabilities Condition=" '$(DefineCommonCapabilities)' == '' ">true</DefineCommonCapabilities>
    <SynthesizeLinkMetadata Condition=" '$(SynthesizeLinkMetadata)' == '' and '$(HasSharedItems)' == 'true' ">true</SynthesizeLinkMetadata>
    <DefaultProjectTypeGuid Condition=" '$(DefaultProjectTypeGuid)' == '' ">{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</DefaultProjectTypeGuid>
    <AppDesignerFolder Condition="'$(AppDesignerFolder)' == ''">Properties</AppDesignerFolder>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCSharpItemSchemas)' != 'false' " xmlns="">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.ProjectItemsSchema.xaml;" />
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.xaml;">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.BrowseObject.xaml;">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <ProjectCapability Include="CSharp;Managed" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' " xmlns="">
    <ProjectCapability Include="ReferencesFolder;LanguageService" />
  </ItemGroup>
  <!--
    The CreateManifestResourceNames target create the manifest resource names from the .RESX
    files.

        [IN]
        @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                              Expected Metadata "Type" can either be "Resx" or "Non-Resx"

        [OUT]
        @(EmbeddedResource) - EmbeddedResource items with metadata

    For C# applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        SubFolder\Resources1.resx => RootNamespace.SubFolder.Resources1 => Build into main assembly
        Resources1.fr.resx => RootNamespace.Resources1.fr => Build into satellite assembly
        Resources1.notaculture.resx => RootNamespace.Resources1.notaculture => Build into main assembly

    For other project systems, this transformation may be different.
    -->
  <PropertyGroup xmlns="">
    <CreateManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateManifestResourceNames" Condition="'@(EmbeddedResource)' != ''" DependsOnTargets="$(CreateManifestResourceNamesDependsOn)" xmlns="">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <!-- Create manifest names for all culture non-resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" PrependCultureAsDirectory="false" UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <ItemGroup>
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' == ''" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveCodeAnalysisRuleSet" Condition="'$(CodeAnalysisRuleSet)' != ''" xmlns="">
    <ResolveCodeAnalysisRuleSet CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)" CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
      <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
    </ResolveCodeAnalysisRuleSet>
  </Target>
  <ItemGroup xmlns="">
    <!-- Activate CPS projects to track folder names in namespace. -->
    <ProjectCapability Include="RelativePathDerivedDefaultNamespace" />
  </ItemGroup>
  <PropertyGroup xmlns="">
    <!-- Provide a facility to override UseHostCompilerIfAvailable-->
    <UseHostCompilerIfAvailable Condition=" '$(UseHostCompilerIfAvailable)' == ''">true</UseHostCompilerIfAvailable>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <DocFileItem Include="$(DocumentationFile)" Condition="'$(DocumentationFile)'!=''" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(PdbFile)' != ''" xmlns="">
    <_DebugSymbolsIntermediatePathTemporary Include="$(PdbFile)" />
    <!-- Add any missing .pdb extension, as the compiler does -->
    <_DebugSymbolsIntermediatePath Include="@(_DebugSymbolsIntermediatePathTemporary->'%(RootDir)%(Directory)%(Filename).pdb')" />
  </ItemGroup>
  <PropertyGroup xmlns="">
    <CoreCompileDependsOn>$(CoreCompileDependsOn);_ComputeNonExistentFileProperty;ResolveCodeAnalysisRuleSet</CoreCompileDependsOn>
    <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
  </PropertyGroup>
  <!--
      The XamlPreCompile target must remain identical to
      the CoreCompile target in Microsoft.CSharp.Core.targets.
      Any updates to one must be made to the other.
-->
  <Target Name="XamlPreCompile" Inputs="$(MSBuildAllProjects);&#xD;&#xA;                @(Compile);&#xD;&#xA;                @(_CoreCompileResourceInputs);&#xD;&#xA;                $(ApplicationIcon);&#xD;&#xA;                $(AssemblyOriginatorKeyFile);&#xD;&#xA;                @(ReferencePath);&#xD;&#xA;                @(CompiledLicenseFile);&#xD;&#xA;                @(LinkResource);&#xD;&#xA;                @(EmbeddedDocumentation);&#xD;&#xA;                $(Win32Resource);&#xD;&#xA;                $(Win32Manifest);&#xD;&#xA;                @(CustomAdditionalCompileInputs);&#xD;&#xA;                @(Page);&#xD;&#xA;                @(ApplicationDefinition);&#xD;&#xA;                $(ResolvedCodeAnalysisRuleSet)" Outputs="@(DocFileItem);&#xD;&#xA;                 @(XamlIntermediateAssembly);&#xD;&#xA;                 @(_DebugSymbolsIntermediatePath);&#xD;&#xA;                 $(NonExistentFile);&#xD;&#xA;                 @(CustomAdditionalCompileOutputs)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''" Returns="" DependsOnTargets="$(CoreCompileDependsOn);GenerateMSBuildEditorConfigFile" xmlns="">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition=" '$(BuildingInsideVisualStudio)' == 'true' and '$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0' ">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <ItemGroup Condition="'$(TargetingClr2Framework)'=='true'">
      <ReferencePath>
        <EmbedInteropTypes />
      </ReferencePath>
    </ItemGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
    <Csc Condition="'%(_CoreCompileResourceInputs.WithCulture)' != 'true'" AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" AnalyzerConfigFiles="@(EditorConfigFiles)" Analyzers="@(Analyzer)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" ChecksumAlgorithm="$(ChecksumAlgorithm)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" DebugType="none" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DisableSdkPath="$(DisableSdkPath)" DocumentationFile="@(DocFileItem)" EmbedAllSources="false" EmbeddedFiles="@(EmbeddedFiles)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" Features="$(Features)" InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)" FileAlignment="$(FileAlignment)" GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" Instrument="$(Instrument)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Nullable="$(Nullable)" Optimize="$(Optimize)" Deterministic="$(Deterministic)" PublicSign="$(PublicSign)" OutputAssembly="@(XamlIntermediateAssembly)" OutputRefAssembly="" PdbFile="" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" ProjectName="$(MSBuildProjectName)" ProvideCommandLineArgs="$(ProvideCommandLineArgs)" References="@(ReferencePath)" RefOnly="false" ReportAnalyzer="$(ReportAnalyzer)" ReportIVTs="$(ReportIVTs)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" RuntimeMetadataVersion="$(RuntimeMetadataVersion)" SharedCompilationId="$(SharedCompilationId)" SkipAnalyzers="true" SkipCompilerExecution="$(SkipCompilerExecution)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" TargetFramework="$(TargetFramework)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" PathMap="$(PathMap)" SourceLink="$(SourceLink)" />
    <!-- Only Applicable to the regular CoreCompile:
              <ItemGroup>
                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
              </ItemGroup>

              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>
-->
    <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
  </Target>
  <PropertyGroup xmlns="">
    <!-- Design-time builds require a newer version than 1.0 to succeed, so override back to inbox in that case -->
    <CSharpCoreTargetsPath Condition="'$(CSharpCoreTargetsPath)' == '' or ('$(DesignTimeBuild)' == 'true' and $(CSharpCoreTargetsPath.Contains('Microsoft.Net.Compilers.1.0.0')))">$(RoslynTargetsPath)\Microsoft.CSharp.Core.targets</CSharpCoreTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CSharpCoreTargetsPath)">

C:\Program Files\dotnet\sdk\9.0.200\Roslyn\Microsoft.CSharp.Core.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Managed.Core.targets">

C:\Program Files\dotnet\sdk\9.0.200\Roslyn\Microsoft.Managed.Core.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
  <!--
    Common targets for managed compilers.
  -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.Tasks.CodeAnalysis.dll" />
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Managed.Core.CurrentVersions.targets">

C:\Program Files\dotnet\sdk\9.0.200\Roslyn\Microsoft.Managed.Core.CurrentVersions.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <CompilerApiVersion>roslyn4.13</CompilerApiVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Roslyn\Microsoft.Managed.Core.targets
============================================================================================================================================
-->
  <Target Name="ShimReferencePathsWhenCommonTargetsDoesNotUnderstandReferenceAssemblies" BeforeTargets="CoreCompile" Condition="'@(ReferencePathWithRefAssemblies)' == ''">
    <!-- 
      FindReferenceAssembliesForReferences target in Common targets populate this item 
      since dev15.3. The compiler targets may be used (via NuGet package) on earlier MSBuilds. 
      If the ReferencePathWithRefAssemblies item is not populated, just use ReferencePaths 
      (implementation assemblies) as they are.
      
      Since XAML inner build runs CoreCompile directly (instead of Compile target),
      it also doesn't invoke FindReferenceAssembliesForReferences listed in CompileDependsOn.
      In that case we also populate ReferencePathWithRefAssemblies with implementation assemblies.
    -->
    <ItemGroup>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_BeforeVBCSCoreCompile" DependsOnTargets="ShimReferencePathsWhenCommonTargetsDoesNotUnderstandReferenceAssemblies">
    <ItemGroup Condition="'$(TargetingClr2Framework)' == 'true'">
      <ReferencePathWithRefAssemblies>
        <EmbedInteropTypes />
      </ReferencePathWithRefAssemblies>
    </ItemGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <!-- TODO: Remove this ItemGroup once it has been moved to "_GenerateCompileInputs" target in Microsoft.Common.CurrentVersion.targets.
         https://github.com/dotnet/roslyn/issues/12223 -->
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
  </Target>
  <!--
    ========================
    SkipAnalyzers Support
    ========================
    
    -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.ShowMessageForImplicitlySkipAnalyzers" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.Tasks.CodeAnalysis.dll" />
  <Target Name="_ComputeSkipAnalyzers" BeforeTargets="CoreCompile">
    <!-- First, force clear non-user facing properties '_SkipAnalyzers' and '_ImplicitlySkipAnalyzers'. -->
    <PropertyGroup>
      <_SkipAnalyzers />
      <_ImplicitlySkipAnalyzers />
    </PropertyGroup>
    <!--
        Then, determine if '_SkipAnalyzers' needs to be 'true' based on user facing property 'RunAnalyzers'.
        If 'RunAnalyzers' is not set, then fallback to user facing property 'RunAnalyzersDuringBuild'.
        Latter property allows users to disable analyzers only for non-design time builds.
        Design time builds are background builds inside Visual Studio,
        see details here: https://github.com/dotnet/project-system/blob/main/docs/design-time-builds.md.
        Setting 'RunAnalyzersDuringBuild' to false, without setting 'RunAnalyzers', allows users to
        continue running analyzers in the background in Visual Studio while typing (i.e. intellisense),
        while disabling analyzer execution on explicitly invoked non-design time builds.
      -->
    <PropertyGroup Condition="'$(RunAnalyzers)' == 'false' or&#xD;&#xA;                              ('$(RunAnalyzers)' == '' and '$(RunAnalyzersDuringBuild)' == 'false')">
      <_SkipAnalyzers>true</_SkipAnalyzers>
    </PropertyGroup>
    <!-- PERF: For builds which are indirectly triggered inside Visual Studio from commands 
               such as from 'Run Tests' or 'Start Debugging', we implicitly skip analyzers and nullable analysis to speed up the build.
               We only do so by default when 'TreatWarningsAsErrors' is not 'true'. For the scenario where
			         'TreatWarningsAsErrors' is 'true', users can explicitly enable this functionality by setting
			         'OptimizeImplicitlyTriggeredBuild' to 'true'.
               NOTE: This feature is currently supported only for SDK-style projects, i.e. UsingMicrosoftNETSdk = true.
    -->
    <PropertyGroup Condition="'$(_SkipAnalyzers)' == '' and&#xD;&#xA;                              '$(IsImplicitlyTriggeredBuild)' == 'true' and&#xD;&#xA;                              '$(UsingMicrosoftNETSdk)' == 'true' and&#xD;&#xA;                              '$(OptimizeImplicitlyTriggeredBuild)' != 'false' and&#xD;&#xA;                              ('$(TreatWarningsAsErrors)' != 'true' or '$(OptimizeImplicitlyTriggeredBuild)' == 'true')">
      <_ImplicitlySkipAnalyzers>true</_ImplicitlySkipAnalyzers>
      <_SkipAnalyzers>true</_SkipAnalyzers>
      <Features>run-nullable-analysis=never;$(Features)</Features>
    </PropertyGroup>
    <!-- Display a message to inform the users about us implicitly skipping analyzers for speeding up indirect builds. -->
    <ShowMessageForImplicitlySkipAnalyzers Condition="'$(_ImplicitlySkipAnalyzers)' == 'true'" />
    <!-- Semaphore file to indicate the time stamp for last build with skipAnalyzers flag. -->
    <PropertyGroup>
      <_LastBuildWithSkipAnalyzers>$(IntermediateOutputPath)$(MSBuildProjectFile).BuildWithSkipAnalyzers</_LastBuildWithSkipAnalyzers>
    </PropertyGroup>
    <!-- '_LastBuildWithSkipAnalyzers' semaphore file, if exists, is passed as custom additional file input to builds without skipAnalyzers flag to ensure correct incremental builds. 
	       Additionally, we need to pass this file as an 'UpToDateCheckInput' item with 'Kind = ImplicitBuild' for project system's fast-upto-date check to work correctly.
		     See https://github.com/dotnet/project-system/issues/7290 for details.
	  -->
    <ItemGroup Condition="Exists('$(_LastBuildWithSkipAnalyzers)') and '$(_SkipAnalyzers)' != 'true'">
      <CustomAdditionalCompileInputs Include="$(_LastBuildWithSkipAnalyzers)" />
      <UpToDateCheckInput Include="$(_LastBuildWithSkipAnalyzers)" Kind="ImplicitBuild" />
    </ItemGroup>
  </Target>
  <!-- We touch and create a semaphore file after build to indicate the time stamp for last build with skipAnalyzers flag. -->
  <Target Name="_TouchLastBuildWithSkipAnalyzers" Condition="'$(_SkipAnalyzers)' == 'true'" AfterTargets="CoreCompile">
    <Touch AlwaysCreate="true" Files="$(_LastBuildWithSkipAnalyzers)" />
  </Target>
  <!--
    ========================
    .editorconfig Support
    ========================
    
    -->
  <ItemGroup>
    <_AllDirectoriesAbove Include="@(Compile-&gt;GetPathsOfAllDirectoriesAbove())" Condition="'$(DiscoverEditorConfigFiles)' != 'false' or '$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
    <!-- Work around a GetPathsOfAllDirectoriesAbove() bug where it can return multiple equivalent paths when the 
         compilation includes linked files with relative paths - https://github.com/microsoft/msbuild/issues/4392 -->
    <PotentialEditorConfigFiles Include="@(_AllDirectoriesAbove-&gt;'%(FullPath)'-&gt;Distinct()-&gt;Combine('.editorconfig'))" Condition="'$(DiscoverEditorConfigFiles)' != 'false'" />
    <EditorConfigFiles Include="@(PotentialEditorConfigFiles-&gt;Exists())" Condition="'$(DiscoverEditorConfigFiles)' != 'false'" />
    <GlobalAnalyzerConfigFiles Include="@(_AllDirectoriesAbove-&gt;'%(FullPath)'-&gt;Distinct()-&gt;Combine('.globalconfig'))" Condition="'$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
    <EditorConfigFiles Include="@(GlobalAnalyzerConfigFiles-&gt;Exists())" Condition="'$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
  </ItemGroup>
  <!--
    ========================
    Property/metadata global .editorconfig Support
    ========================
    
    Generates a global editor config that contains the evaluation of requested MSBuild properties and item metadata
    
    Requested properties/items are requested via item groups like:
   
      <CompilerVisibleProperty Include="PropertyNameToEval" />
      <CompilerVisibleItemMetadata Include="ItemType" MetadataName="MetadataToRetrieve" />
    -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.Tasks.CodeAnalysis.dll" />
  <Target Name="GenerateMSBuildEditorConfigFile" BeforeTargets="BeforeCompile;CoreCompile" DependsOnTargets="PrepareForBuild;GenerateMSBuildEditorConfigFileShouldRun;GenerateMSBuildEditorConfigFileCore" />
  <Target Name="GenerateMSBuildEditorConfigFileShouldRun">
    <PropertyGroup>
      <GeneratedMSBuildEditorConfigFile Condition="'$(GeneratedMSBuildEditorConfigFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).GeneratedMSBuildEditorConfig.editorconfig</GeneratedMSBuildEditorConfigFile>
      <GenerateMSBuildEditorConfigFile Condition="'$(GenerateMSBuildEditorConfigFile)' == ''">true</GenerateMSBuildEditorConfigFile>
      <_GeneratedEditorConfigHasItems Condition="'@(CompilerVisibleItemMetadata-&gt;Count())' != '0'">true</_GeneratedEditorConfigHasItems>
      <_GeneratedEditorConfigShouldRun Condition="'$(GenerateMSBuildEditorConfigFile)' == 'true' and ('$(_GeneratedEditorConfigHasItems)' == 'true' or '@(CompilerVisibleProperty-&gt;Count())' != '0')">true</_GeneratedEditorConfigShouldRun>
    </PropertyGroup>
  </Target>
  <Target Name="GenerateMSBuildEditorConfigFileCore" Condition="'$(_GeneratedEditorConfigShouldRun)' == 'true'" Outputs="$(GeneratedMSBuildEditorConfigFile)">
    <ItemGroup>
      <!-- Collect requested properties, and eval their value -->
      <_GeneratedEditorConfigProperty Include="@(CompilerVisibleProperty)">
        <Value>$(%(CompilerVisibleProperty.Identity))</Value>
      </_GeneratedEditorConfigProperty>
      <!-- Collect the requested items and remember which metadata is wanted -->
      <_GeneratedEditorConfigMetadata Include="@(%(CompilerVisibleItemMetadata.Identity))" Condition="'$(_GeneratedEditorConfigHasItems)' == 'true'">
        <ItemType>%(Identity)</ItemType>
        <MetadataName>%(CompilerVisibleItemMetadata.MetadataName)</MetadataName>
      </_GeneratedEditorConfigMetadata>
      <!-- Record that we'll write a file, and add it to the analyzerconfig inputs -->
      <FileWrites Include="$(GeneratedMSBuildEditorConfigFile)" />
      <EditorConfigFiles Include="$(GeneratedMSBuildEditorConfigFile)" />
    </ItemGroup>
    <!-- Transform the collected properties and items into an editor config file -->
    <GenerateMSBuildEditorConfig PropertyItems="@(_GeneratedEditorConfigProperty)" MetadataItems="@(_GeneratedEditorConfigMetadata)" FileName="$(GeneratedMSBuildEditorConfigFile)" />
  </Target>
  <!--
    ========================
    DeterministicSourcePaths
    ========================
    
    Unless specified otherwise enable deterministic source root (PathMap) when building deterministically on CI server, but not for local builds.
    In order for the debugger to find source files when debugging a locally built binary the PDB must contain original, unmapped local paths.
  -->
  <PropertyGroup>
    <DeterministicSourcePaths Condition="'$(DeterministicSourcePaths)' == '' and '$(Deterministic)' == 'true' and '$(ContinuousIntegrationBuild)' == 'true'">true</DeterministicSourcePaths>
  </PropertyGroup>
  <!--
    ==========
    SourceRoot
    ==========

    All source files of the project are expected to be located under one of the directories specified by SourceRoot item group.
    This target collects all SourceRoots from various sources.

    This target calculates final local path for each SourceRoot and sets SourceRoot.MappedPath metadata accordingly.
    The final path is a path with deterministic prefix when DeterministicSourcePaths is true, and the original path otherwise.
    In addition, the target validates and deduplicates the SourceRoot items.

    InitializeSourceControlInformation is an msbuild target that ensures the SourceRoot items are populated from source control.
    The target is available only if SourceControlInformationFeatureSupported is true.

    A consumer of SourceRoot.MappedPath metadata, such as Source Link generator, shall depend on this target. 
  -->
  <Target Name="InitializeSourceRootMappedPaths" DependsOnTargets="_InitializeSourceRootMappedPathsFromSourceControl" Returns="@(SourceRoot)">
    <ItemGroup Condition="'@(_MappedSourceRoot)' != ''">
      <_MappedSourceRoot Remove="@(_MappedSourceRoot)" />
    </ItemGroup>
    <Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots SourceRoots="@(SourceRoot)" Deterministic="$(DeterministicSourcePaths)">
      <Output TaskParameter="MappedSourceRoots" ItemName="_MappedSourceRoot" />
    </Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_MappedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!-- 
    Declare that target InitializeSourceRootMappedPaths that populates MappedPaths metadata on SourceRoot items is available.
  -->
  <PropertyGroup>
    <SourceRootMappedPathsFeatureSupported>true</SourceRootMappedPathsFeatureSupported>
  </PropertyGroup>
  <!-- 
    If InitializeSourceControlInformation target isn't supported, we just continue without invoking that synchronization target. 
    We'll proceed with SourceRoot (and other source control properties) provided by the user (or blank).
  -->
  <Target Name="_InitializeSourceRootMappedPathsFromSourceControl" DependsOnTargets="InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" />
  <!-- 
    =======
    PathMap
    =======

    If DeterministicSourcePaths is true sets PathMap based on SourceRoot.MappedPaths.

    This target requires SourceRoot to be initialized in order to calculate the PathMap.
    If SourceRoot doesn't contain any top-level roots an error is reported.
  -->
  <Target Name="_SetPathMapFromSourceRoots" DependsOnTargets="InitializeSourceRootMappedPaths" BeforeTargets="CoreCompile" Condition="'$(DeterministicSourcePaths)' == 'true'">
    <ItemGroup>
      <_TopLevelSourceRoot Include="@(SourceRoot)" Condition="'%(SourceRoot.NestedRoot)' == ''">
        <EscapedKey>$([MSBuild]::ValueOrDefault('%(Identity)', '').Replace(',', ',,').Replace('=', '=='))</EscapedKey>
        <EscapedValue>$([MSBuild]::ValueOrDefault('%(MappedPath)', '').Replace(',', ',,').Replace('=', '=='))</EscapedValue>
      </_TopLevelSourceRoot>
    </ItemGroup>
    <PropertyGroup Condition="'@(_TopLevelSourceRoot)' != ''">
      <!--
        Prepend the SourceRoot.MappedPath values to PathMap, if it already has a value.
        For each emitted source path the compiler applies the first mapping that matches the path.
        PathMap values set previously will thus only be applied if the mapping provided by 
        SourceRoot.MappedPath doesn't match. Since SourceRoot.MappedPath is also used by SourceLink 
        preferring it over manually set PathMap ensures that PathMap is consistent with SourceLink.
      -->
      <PathMap>@(_TopLevelSourceRoot->'%(EscapedKey)=%(EscapedValue)', ','),$(PathMap)</PathMap>
    </PropertyGroup>
  </Target>
  <!--
    =======
    CopyAdditionalFiles
    =======

    If a user requests that any @(AdditionalFiles) items are copied to the output directory
    we add them to the @(None) group to ensure they will be copied.
 -->
  <Target Name="CopyAdditionalFiles" BeforeTargets="AssignTargetPaths">
    <ItemGroup>
      <None Include="@(AdditionalFiles)" Condition="'%(AdditionalFiles.CopyToOutputDirectory)' != ''" />
    </ItemGroup>
  </Target>
  <!--
    ========================
    CompilerGeneratedFilesOutputPath
    ========================
    
    Controls output of generated files.
    
    CompilerGeneratedFilesOutputPath controls the location the files will be output to.
    The compiler will not emit any generated files when the path is empty, and defaults to a /generated directory in $(IntermediateOutputPath) if $(IntermediateOutputPath) has a value.
    A relative path is considered relative to the project directory.

    EmitCompilerGeneratedFiles allows the user to control if anything is emitted by clearing the property when not true.
    When EmitCompilerGeneratedFiles is true, we ensure that CompilerGeneatedFilesOutputPath has a value and issue a warning if not.

    We will create CompilerGeneratedFilesOutputPath if it does not exist.
    -->
  <PropertyGroup>
    <EmitCompilerGeneratedFiles Condition="'$(EmitCompilerGeneratedFiles)' == ''">false</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath Condition="'$(EmitCompilerGeneratedFiles)' != 'true'" />
    <CompilerGeneratedFilesOutputPath Condition="'$(EmitCompilerGeneratedFiles)' == 'true' and '$(CompilerGeneratedFilesOutputPath)' == '' and '$(IntermediateOutputPath)' != ''">$(IntermediateOutputPath)/generated</CompilerGeneratedFilesOutputPath>
  </PropertyGroup>
  <Target Name="CreateCompilerGeneratedFilesOutputPath" BeforeTargets="CoreCompile" Condition="'$(EmitCompilerGeneratedFiles)' == 'true' and !('$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true')">
    <Warning Condition="'$(CompilerGeneratedFilesOutputPath)' == ''" Text="EmitCompilerGeneratedFiles was true, but no CompilerGeneratedFilesOutputPath was provided. CompilerGeneratedFilesOutputPath must be set in order to emit generated files." />
    <MakeDir Condition="'$(CompilerGeneratedFilesOutputPath)' != ''" Directories="$(CompilerGeneratedFilesOutputPath)" />
  </Target>
  <!--
    ========================
    Component Debugger Support
    ========================
    
    Add the specified VS capability if a user indicates this project supports component debugging
    -->
  <ItemGroup>
    <ProjectCapability Include="RoslynComponent" Condition="'$(IsRoslynComponent)' == 'true'" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Roslyn\Microsoft.CSharp.Core.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- .NETCoreApp < 3.0, .NETStandard < 2.1, or any other target framework -->
    <_MaxSupportedLangVersion Condition="('$(TargetFrameworkIdentifier)' != '.NETCoreApp' OR '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0') AND&#xD;&#xA;                                         ('$(TargetFrameworkIdentifier)' != '.NETStandard' OR '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1')">7.3</_MaxSupportedLangVersion>
    <!-- .NETCoreApp < 5.0, .NETStandard == 2.1 -->
    <_MaxSupportedLangVersion Condition="(('$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND '$(_TargetFrameworkVersionWithoutV)' &lt; '5.0') OR&#xD;&#xA;                                          ('$(TargetFrameworkIdentifier)' == '.NETStandard' AND '$(_TargetFrameworkVersionWithoutV)' == '2.1')) AND&#xD;&#xA;                                          '$(_MaxSupportedLangVersion)' == ''">8.0</_MaxSupportedLangVersion>
    <!-- 
      Automatically calculate the maximum supported C# language version based on the .NET Target Framework.
      - Pattern: .NET 5.0 uses C# 9.0, .NET 6.0 uses C# 10.0, and so on.
      - Starting from C# 9.0 for .NET 5.0, we add the difference between the major .NET version and 5 
        to determine the correct language version.
      NOTE: `.Split('.')[0]` needed due to https://github.com/dotnet/msbuild/issues/9757.
    -->
    <_MaxSupportedLangVersion Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND&#xD;&#xA;                                         '$(_MaxSupportedLangVersion)' == ''">$([MSBuild]::Add(9, $([MSBuild]::Subtract($(_TargetFrameworkVersionWithoutV.Split('.')[0]), 5)))).0</_MaxSupportedLangVersion>
    <!-- Cap _MaxSupportedLangVersion if it exceeds _MaxAvailableLangVersion -->
    <_MaxAvailableLangVersion>13.0</_MaxAvailableLangVersion>
    <_MaxSupportedLangVersion Condition="'$(_MaxSupportedLangVersion)' != '' AND&#xD;&#xA;                                         '$(_MaxSupportedLangVersion)' &gt; '$(_MaxAvailableLangVersion)'">$(_MaxAvailableLangVersion)</_MaxSupportedLangVersion>
    <MaxSupportedLangVersion>$(_MaxSupportedLangVersion)</MaxSupportedLangVersion>
    <LangVersion Condition="'$(LangVersion)' == '' AND '$(_MaxSupportedLangVersion)' != ''">$(_MaxSupportedLangVersion)</LangVersion>
  </PropertyGroup>
  <Target Name="CoreCompile" Inputs="$(MSBuildAllProjects);&#xD;&#xA;                  @(Compile);&#xD;&#xA;                  @(_CoreCompileResourceInputs);&#xD;&#xA;                  $(ApplicationIcon);&#xD;&#xA;                  $(KeyOriginatorFile);&#xD;&#xA;                  @(ReferencePathWithRefAssemblies);&#xD;&#xA;                  @(CompiledLicenseFile);&#xD;&#xA;                  @(LinkResource);&#xD;&#xA;                  @(EmbeddedDocumentation);&#xD;&#xA;                  $(Win32Resource);&#xD;&#xA;                  $(Win32Manifest);&#xD;&#xA;                  @(CustomAdditionalCompileInputs);&#xD;&#xA;                  $(ResolvedCodeAnalysisRuleSet);&#xD;&#xA;                  @(AdditionalFiles);&#xD;&#xA;                  @(EmbeddedFiles);&#xD;&#xA;                  @(Analyzer);&#xD;&#xA;                  @(EditorConfigFiles);&#xD;&#xA;                  $(SourceLink)" Outputs="@(DocFileItem);&#xD;&#xA;                   @(IntermediateAssembly);&#xD;&#xA;                   @(IntermediateRefAssembly);&#xD;&#xA;                   @(_DebugSymbolsIntermediatePath);&#xD;&#xA;                   $(NonExistentFile);&#xD;&#xA;                   @(CustomAdditionalCompileOutputs)" Returns="@(CscCommandLineArgs)" DependsOnTargets="$(CoreCompileDependsOn);_BeforeVBCSCoreCompile">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition="'$(BuildingInsideVisualStudio)' == 'true' AND '$(VisualStudioVersion)' != '' AND '$(VisualStudioVersion)' &gt; '10.0'">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' AND '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' AND '$(OutputType)' == 'winmdobj' AND '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <Csc Condition="'%(_CoreCompileResourceInputs.WithCulture)' != 'true'" AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" AnalyzerConfigFiles="@(EditorConfigFiles)" Analyzers="@(Analyzer)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" ChecksumAlgorithm="$(ChecksumAlgorithm)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" DebugType="$(DebugType)" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DisableSdkPath="$(DisableSdkPath)" DocumentationFile="@(DocFileItem)" EmbedAllSources="$(EmbedAllSources)" EmbeddedFiles="@(EmbeddedFiles)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" Features="$(Features)" InterceptorsNamespaces="$(InterceptorsNamespaces)" InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)" FileAlignment="$(FileAlignment)" GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" Instrument="$(Instrument)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Nullable="$(Nullable)" Optimize="$(Optimize)" Deterministic="$(Deterministic)" PublicSign="$(PublicSign)" OutputAssembly="@(IntermediateAssembly)" OutputRefAssembly="@(IntermediateRefAssembly)" PdbFile="$(PdbFile)" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" ProjectName="$(MSBuildProjectName)" ProvideCommandLineArgs="$(ProvideCommandLineArgs)" References="@(ReferencePathWithRefAssemblies)" RefOnly="$(ProduceOnlyReferenceAssembly)" ReportAnalyzer="$(ReportAnalyzer)" ReportIVTs="$(ReportIVTs)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" RuntimeMetadataVersion="$(RuntimeMetadataVersion)" SharedCompilationId="$(SharedCompilationId)" SkipAnalyzers="$(_SkipAnalyzers)" SkipCompilerExecution="$(SkipCompilerExecution)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" TargetFramework="$(TargetFramework)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" PathMap="$(PathMap)" SourceLink="$(SourceLink)">
      <Output TaskParameter="CommandLineArgs" ItemName="CscCommandLineArgs" />
    </Csc>
    <ItemGroup>
      <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
    </ItemGroup>
    <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''" />
  </Target>
  <!-- When we load a project in Visual Studio, the project system first does an evaluation pass of the
       project, and hands the resulting list of <Compile> items to the language service. It then does an
       execution pass executing CoreCompile passing SkipCompilerExecution=true and ProvideCommandLineArgs=true,
       that resulting command line string is where we get our compiler switches. The execution pass is much
       slower than the evaluation pass, so there's a window of time where we have a list of files, but not
       any options yet.

       Because there's a gap, that means there's a time where we are parsing source files with the default
       parse options. We'll then have to reparse them a second time which isn't great. It also means any
       cache lookups we do won't have the right options either, so the cache lookups might miss.

       To help this, we'll have properties for the evaluation pass which is an "approximation" of the
       options that would come out of CoreCompile, but only the ones that are required to be specified
       and we don't expect them to change after evaluation phase or those that matter for parsing.

       It's acceptable for the options that affect parsing to be imperfect: once the execution pass is complete we'll use those options instead,
       so any behaviors here that don't match the real command line generation will only be temporary, and
       probably won't be any worse than having no options at all. -->
  <PropertyGroup>
    <CommandLineArgsForDesignTimeEvaluation>-langversion:$(LangVersion)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(ChecksumAlgorithm)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -checksumalgorithm:$(ChecksumAlgorithm)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(DefineConstants)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -define:$(DefineConstants)</CommandLineArgsForDesignTimeEvaluation>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
  <!-- Import design time targets before the common targets, which import targets from Nuget. -->
  <PropertyGroup xmlns="">
    <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Common.targets">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <CommonTargetsPath>$(MSBuildToolsPath)\Microsoft.Common.CurrentVersion.targets</CommonTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CommonTargetsPath)">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(MicrosoftCommonPropsHasBeenImported)' != 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />-->
  <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
  <PropertyGroup xmlns="">
    <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
    <ReportingServicesTargets Condition="'$(ReportingServicesTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\ReportingServices\Microsoft.ReportingServices.targets</ReportingServicesTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="'$(CustomBeforeMicrosoftCommonTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonTargets)')" />-->
  <!-- By default, we are creating a managed app because .NET 2.0 projects did not have this property. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == ''" xmlns="">
    <TargetRuntime>Managed</TargetRuntime>
  </PropertyGroup>
  <!-- Because .NET 2.0 apps did not set TargetFrameworkIdentifier, we need to set it for them here by default.  If
       the runtime is set to Managed, we also need to set these.  Otherwise they should be blank (for instance Javascript or
       Native apps) because they do not target a .NET Framework. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed'" xmlns="">
    <TargetFrameworkIdentifier Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
    <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v4.0</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- AvailablePlatforms is the list of platform targets available. -->
  <PropertyGroup xmlns="">
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' == '10.0' or '$(VisualStudioVersion)' == ''">Any CPU,x86,x64,Itanium</AvailablePlatforms>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0'">Any CPU,x86,x64</AvailablePlatforms>
  </PropertyGroup>
  <!-- Import depends on if it is .NETCore. Imports for .NETFramework is a superset of that for .NETCore-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NETFramework.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight'">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetFramework.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .net framework specific properties, items and targets. They are factored into a Microsoft.NETFramework.targets and Microsoft.NetFramework.props
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <NetFrameworkPropsPath>$(MSBuildToolsPath)\Microsoft.NETFramework.CurrentVersion.props</NetFrameworkPropsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetFrameworkPropsPath)">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.CurrentVersion.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETFramework.CurrentVersion.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .net framework specific properties, items and targets. They are factored into a Microsoft.NETFramework.targets and Microsoft.NetFramework.props
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportByWildcardAfterMicrosoftNetFrameworkProps Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardAfterMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportBefore')" />-->
  <PropertyGroup xmlns="">
    <!-- By default we want to replace subsets with profiles, but we do need a way to turning off this "upgrade" in case a user needs to target a subset-->
    <UpgradeSubsetToProfile Condition="'$(UpgradeSubsetToProfile)' == '' ">true</UpgradeSubsetToProfile>
    <TargetFrameworkProfile Condition="'$(UpgradeSubsetToProfile)' == 'true' and '$(TargetFrameworkSubset)' != '' and '$(TargetFrameworkProfile)' == ''">$(TargetFrameworkSubset)</TargetFrameworkProfile>
    <!-- If we are not upgrading the Subset to a profile this means we want to target a subset, do not wipe out the subset name-->
    <TargetFrameworkSubset Condition="'$(UpgradeTargetFrameworkSubsetToProfile)' == 'true'" />
  </PropertyGroup>
  <PropertyGroup Condition="'$(FrameworkPathOverride)' != ''" xmlns="">
    <_FullFrameworkReferenceAssemblyPaths>$(FrameworkPathOverride)</_FullFrameworkReferenceAssemblyPaths>
    <_TargetFrameworkDirectories>$(FrameworkPathOverride)</_TargetFrameworkDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion)' == 'v4.0' and '$(FrameworkPathOverride)' == ''" xmlns="">
    <!-- The FrameworkPathOverride property is required for the IDE Visual Basic compiler to initialize.
        This location contains reference assemblies for mscorlib.dll and other key VB assemblies.
        This property is required during project evaluation, since the IDE compilers need to initialize before
        any targets have had a chance to run, hence the use of a function to retrieve the location.
     -->
    <!-- Hard code for the most common TargetFrameworkVersion of v4.0 with no profile: this enables us to avoid calling the GetReferenceAssemblyPaths task -->
    <_FullFrameworkReferenceAssemblyPaths Condition="Exists('$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\RedistList\FrameworkList.xml')">$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0</_FullFrameworkReferenceAssemblyPaths>
    <_TargetFrameworkDirectories Condition="'$(TargetFrameworkProfile)' == ''">$(_FullFrameworkReferenceAssemblyPaths)</_TargetFrameworkDirectories>
    <FrameworkPathOverride Condition="'$(TargetFrameworkProfile)' == ''">$(_TargetFrameworkDirectories)</FrameworkPathOverride>
    <!-- Hard code for the most common TargetFrameworkVersion of v4.0 with Client profile: this enables us to avoid calling the GetReferenceAssemblyPaths task -->
    <_TargetFrameworkDirectories Condition="'$(TargetFrameworkProfile)' == 'Client' and Exists('$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\$(TargetFrameworkProfile)\RedistList\FrameworkList.xml')">$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\$(TargetFrameworkProfile)</_TargetFrameworkDirectories>
    <FrameworkPathOverride Condition="'$(TargetFrameworkProfile)' == 'Client'">$(_TargetFrameworkDirectories)</FrameworkPathOverride>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkMonikerDisplayName)' == '' and '$(TargetFrameworkProfile)' == ''">.NET Framework 4</TargetFrameworkMonikerDisplayName>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkMonikerDisplayName)' == '' and '$(TargetFrameworkProfile)' == 'Client'">.NET Framework 4 Client Profile</TargetFrameworkMonikerDisplayName>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <MSBuildFrameworkToolsRoot Condition="'$(MSBuildFrameworkToolsRoot)' == '' and '$(MSBuildRuntimeType)' != 'Core'">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\.NETFramework@InstallRoot)</MSBuildFrameworkToolsRoot>
    <_DeploymentSignClickOnceManifests Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(SignManifests)' == 'true'">true</_DeploymentSignClickOnceManifests>
    <!-- Assembly names added to the AdditionalExplicitAssemblyReferences property will be added as references to the resolve assembly reference call by default this is done because when upgrading from
        a project targeting 2.0 to 3.5 the system.core reference is not added, therefore we need to add it automatically -->
    <AddAdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == ''">true</AddAdditionalExplicitAssemblyReferences>
    <AdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == 'true' and '$(TargetCompactFramework)' != 'true' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0')">System.Core;$(AdditionalExplicitAssemblyReferences)</AdditionalExplicitAssemblyReferences>
  </PropertyGroup>
  <!--
    ============================================================
                                        GetToolPaths
    Get the paths for the .NET Framework tools and sdk tools directories.
    This does not need to be a target since all of the values are availiable at project evaluation time.
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <TargetingClr2Framework Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">true</TargetingClr2Framework>
    <MSBuildManagedCompilerPath Condition="'$(TargetingClr2Framework)' == 'true'">$(MSBuildFrameworkToolsRoot)\v3.5</MSBuildManagedCompilerPath>
    <TargetFrameworkSDKToolsDirectory Condition="'$(TargetingClr2Framework)' == 'true'">$(SDK35ToolsPath)</TargetFrameworkSDKToolsDirectory>
    <!-- If the sdk path is not 3.5 or lower set it to the 40 sdk tools path. This will allow future target framework versions to use the 4.0 sdk tool set
        When a new windows SDK revs they will inplace update the location pointed to by this property. When a new sdk is release this target will have to be
        revised along with another toolsversion. -->
    <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == '' and ('$(TargetingClr2Framework)' == 'true')">v2.0.50727</TargetedRuntimeVersion>
    <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == ''">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '') and '$(PreferNativeArm64)' != 'true'" xmlns="">
    <Prefer32Bit Condition="'$(Prefer32Bit)' == ''">true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <Prefer32Bit Condition="'$(Prefer32Bit)' == ''">false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- ARM and AppContainerExe require subsystem version >= 6.02 (Windows 8) -->
    <SubsystemVersion Condition="'$(SubsystemVersion)' == '' and ('$(PlatformTarget)' == 'ARM' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == 'winmdobj')">6.02</SubsystemVersion>
    <!-- Starting with .Net 4.5 projects use subsystem 6.00 (Vista) as default -->
    <SubsystemVersion Condition="'$(SubsystemVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0')">6.00</SubsystemVersion>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ComReferenceExecuteAsTool Condition="'$(ExecuteAsTool)'!=''">$(ExecuteAsTool)</ComReferenceExecuteAsTool>
    <ComReferenceExecuteAsTool Condition="'$(ExecuteAsTool)'=='' and '$(TargetingClr2Framework)' == 'true'">true</ComReferenceExecuteAsTool>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ResGenExecuteAsTool Condition="'$(ExecuteAsTool)'!=''">$(ExecuteAsTool)</ResGenExecuteAsTool>
    <ResGenExecuteAsTool Condition="'$(ExecuteAsTool)'=='' and '$(TargetingClr2Framework)' == 'true'">true</ResGenExecuteAsTool>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- Starting with .NET 4.5 projects we implictly reference all portable design-time facades -->
    <ImplicitlyExpandDesignTimeFacades Condition="'$(ImplicitlyExpandDesignTimeFacades)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0')">true</ImplicitlyExpandDesignTimeFacades>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <AvailablePlatforms Condition="!$(AvailablePlatforms.Contains('ARM64')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '4.0'))">$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <!--Import props that are common for both full framework and core.
      And before the ImportAfter\* , so users can override it-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.NET.props">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NET.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .NET-specific properties, and items. This file is imported for .NET Core, .NET Standard, and .NET Framework projects.
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                        GetToolPaths
    Get the paths for the .NET Framework and .NET Core tools and sdk tools directories.
    This does not need to be a target since all of the values are availiable at project evaluation time.
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <TargetFrameworkSDKToolsDirectory Condition=" '$(TargetFrameworkSDKToolsDirectory)' == '' ">$(SDK40ToolsPath)</TargetFrameworkSDKToolsDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetHighEntropyVA
    Set HighEntropyVA according to the TargetFramework
    ============================================================
  -->
  <PropertyGroup Condition="('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0') or '$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETStandard'" xmlns="">
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">true</HighEntropyVA>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">false</HighEntropyVA>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.CurrentVersion.props
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="Microsoft.NET.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' or '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" />-->
  <PropertyGroup xmlns="">
    <!-- Generates full paths for the 'File' property in errors, warnings and messages in many targets -->
    <GenerateFullPaths Condition="'$(GenerateFullPaths)' == ''">true</GenerateFullPaths>
    <!-- Yield optimization properties -->
    <YieldDuringToolExecution Condition="'$(YieldDuringToolExecution)' == ''">true</YieldDuringToolExecution>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' != '' and '$(TargetFrameworkVersion)' != ''" xmlns="">
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == '' and '$([System.String]::IsNullOrWhitespace($(TargetFrameworkProfile)))' != 'true'">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion),Profile=$(TargetFrameworkProfile)</TargetFrameworkMoniker>
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
    <!-- When working off a packaged reference assemblies, do not go to machine-global locations. This property is target-framework-specific, so it cannot be overridden in msbuild.exe.config once and for all. -->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == '' And Exists('$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)')">$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)</FrameworkPathOverride>
    <!-- The FrameworkPathOverride is required for the inproc visual basic compiler to initialize when targeting target frameworks less than 4.0. If .net 2.0 is not installed then the property value above will not provide the location
             of mscorlib. This is also true if the build author overrides this property to some other directory which does not contain mscorlib.dll. In the case we cannot find mscorlib.dll at the correct location
             we need to find a directory which does contain mscorlib to allow the inproc compiler to initialize and give us the chance to show certain dialogs in the IDE (which only happen after initialization).-->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToStandardLibraries($(TargetFrameworkIdentifier), $(TargetFrameworkVersion), $(TargetFrameworkProfile), $(PlatformTarget), $(TargetFrameworkRootPath), $(TargetFrameworkFallbackSearchPaths)))</FrameworkPathOverride>
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And !Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">Windows</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">7.0</TargetPlatformVersion>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and $([MSBuild]::IsOSPlatform('Windows')) and '$(MSBuildRuntimeType)' != 'Core'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
    <TargetPlatformSdkMetadataLocation Condition="'$(TargetPlatformSdkMetadataLocation)' == '' and Exists('$(TargetPlatformSdkPath)')">$(TargetPlatformSdkPath)Windows Metadata</TargetPlatformSdkMetadataLocation>
    <TargetPlatformSdkMetadataLocation Condition="Exists('$(TargetPlatformSdkPath)') and ('$(TargetPlatformSdkMetadataLocation)' == '' or !Exists('$(TargetPlatformSdkMetadataLocation)'))">$(TargetPlatformSdkPath)References\CommonConfiguration\Neutral</TargetPlatformSdkMetadataLocation>
    <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
    <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
    <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != '' and '$(TargetPlatformVersion)' != ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!--
    Several properties must be set in the main project file, before using this .TARGETS file.
    However, if the properties are not set, we pick some defaults.

    OutDir:
    Indicates the final output location for the project or solution. When building a solution,
    OutDir can be used to gather multiple project outputs in one location. In addition,
    OutDir is included in AssemblySearchPaths used for resolving references.

    BaseOutputPath:
    This is the top level folder where all configuration specific output folders will be created.
    Default value is bin\

    OutputPath:
    This is the full Output Path, and is derived from BaseOutputPath, if none specified
    (eg. bin\Debug). If this property is overridden, then setting BaseOutputPath has no effect.

    For Legacy projects using only Common targets, this property is usually specified in the project file
    and is used to initialize OutDir. Some SDKs including the .NET SDK derive this automatically.
    OutDir and OutputPath are distinguished for legacy reasons, and OutDir should be used if at all possible.

    BaseIntermediateOutputPath:
    This is the top level folder where all configuration specific intermediate output folders will be created.
    Default value is obj\

    IntermediateOutputPath:
    This is the full intermediate Output Path, and is derived from BaseIntermediateOutputPath, if none specified
    (eg. obj\Debug). If this property is overridden, then setting BaseIntermediateOutputPath has no effect.

    Ensure any and all path property has a trailing slash, so it can be concatenated.
    -->
  <PropertyGroup xmlns="">
    <!-- Example, AnyCPU -->
    <_OriginalPlatform>$(Platform)</_OriginalPlatform>
    <!-- Example, Debug -->
    <_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
    <!-- Check whether OutputPath was specified for valid Configuration/Platform combination -->
    <_OutputPathWasMissing Condition="'$(_OriginalPlatform)' != '' and '$(_OriginalConfiguration)' != '' and '$(OutputPath)' == ''">true</_OutputPathWasMissing>
    <!-- Check whether BaseOutputPath was specified -->
    <BaseOutputPathWasSpecified Condition="'$(BaseOutputPath)' != ''">true</BaseOutputPathWasSpecified>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <Platform Condition="'$(Platform)' == ''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- Determine OutputType property from the legacy TargetType property -->
    <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
    <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
    <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>
    <DebugSymbols Condition=" '$(ConfigurationName)' == 'Debug' and '$(DebugSymbols)' == '' and '$(DebugType)'==''">true</DebugSymbols>
    <!-- Whether or not a .pdb file is produced. -->
    <_DebugSymbolsProduced>false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='portable'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='embedded'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(ProduceOnlyReferenceAssembly)'=='true'">false</_DebugSymbolsProduced>
    <!-- Whether or not a .xml file is produced. -->
    <_DocumentationFileProduced>true</_DocumentationFileProduced>
    <_DocumentationFileProduced Condition="'$(DocumentationFile)'==''">false</_DocumentationFileProduced>
    <!-- Whether or not a reference assembly is produced. -->
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == ''">false</ProduceReferenceAssembly>
  </PropertyGroup>
  <!--
    For Legacy projects that define properties per Configuration/Platform combination, the validity of an
    invalid combination is determined by the non-empty value of the 'OutputPath' property specified under
    the IDE generated Configuration/Platform specific 'PropertyGroup' section.

    If 'BaseOutputPath' is specified, we can skip the validation, since, we assume the 'OutputPath' property
    will be derived (e.g.: from the 'BaseOutputPath' property).
  -->
  <PropertyGroup Condition="'$(BaseOutputPathWasSpecified)' != 'true' and '$(_OutputPathWasMissing)' == 'true'" xmlns="">
    <!--
        When 'OutputPath' is missing or empty (along with non-existent 'BaseOutputPath') at this point means,
        we're in legacy mode and we shall assume the current Configuration/Platform combination as invalid.
        Whether this is considered an error or a warning depends on the value of $(SkipInvalidConfigurations).
    -->
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' == 'true' ">Warning</_InvalidConfigurationMessageSeverity>
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' != 'true' ">Error</_InvalidConfigurationMessageSeverity>
  </PropertyGroup>
  <!--
    IDE Macros available from both integrated builds and from command line builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps.
  -->
  <PropertyGroup xmlns="">
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='exe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='appcontainerexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='library'">.dll</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='module'">.netmodule</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winmdobj'">.winmdobj</TargetExt>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- Required for enabling Team Build for packaging app package-generating projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
    <!-- Example, bin\Debug\ -->
    <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
    <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
    <!-- Example, MyProject -->
    <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
    <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
    <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
    <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>
    <!-- Example, MyAssembly -->
    <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>
    <!-- Example, MyProject.csproj -->
    <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>
    <!-- Example, .csproj -->
    <WinMDExpOutputWindowsMetadataFilename Condition="'$(WinMDExpOutputWindowsMetadataFilename)' == '' and '$(OutputType)' == 'winmdobj'">$(TargetName).winmd</WinMDExpOutputWindowsMetadataFilename>
    <TargetFileName Condition=" '$(TargetFileName)' == '' and '$(OutputType)' == 'winmdobj'">$(WinMDExpOutputWindowsMetadataFilename)</TargetFileName>
    <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>
    <!-- Example, MyAssembly.dll -->
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!--
        The PublishableProject property is used when invoking the publish target on a solution that
        contains multiple projects. The property determines which projects should be published, and
        which projects should be skipped in the publish target. By default any "Windows Application"
        or "Console Application" project type is publishable. However, a project that would otherwise
        be published can be skipped by defining the PublishableProject property in the project itself.
        -->
    <_DeploymentPublishableProjectDefault Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">true</_DeploymentPublishableProjectDefault>
    <PublishableProject Condition="'$(PublishableProject)'==''">$(_DeploymentPublishableProjectDefault)</PublishableProject>
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, Native.MyAssembly.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='appcontainerexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' != 'true'">$(AssemblyName).application</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.application -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.xbap -->
    <GenerateClickOnceManifests Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">$(GenerateManifests)</GenerateClickOnceManifests>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='winexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='exe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='appcontainerexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' != 'true'">$(AssemblyName).application</_DeploymentDeployManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</_DeploymentDeployManifestIdentity>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'=='true'">.deploy</_DeploymentFileMappingExtension>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'!='true'" />
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'=='true'">$(UpdateInterval)</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'=='true'">$(UpdateIntervalUnits)</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'!='true'">0</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
    <_DeploymentLauncherBased Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_DeploymentLauncherBased>
    <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!--
        By default, GenerateApplicationManifest puts all satellite assemblies to the manifest
        record by default by setting TargetCulture to *.
        -->
    <TargetCulture Condition="'$(TargetCulture)'==''">*</TargetCulture>
    <FallbackCulture Condition="'$(UICulture)'!='' and '$(FallbackCulture)'==''">$(UICulture)</FallbackCulture>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- Not used any more-->
    <_OutputPathItem Include="$(OutDir)" />
    <_UnmanagedRegistrationCache Include="$(BaseIntermediateOutputPath)$(MSBuildProjectFile).UnmanagedRegistration.cache" />
    <_ResolveComReferenceCache Include="$(IntermediateOutputPath)$(MSBuildProjectFile).ResolveComReference.cache" />
  </ItemGroup>
  <PropertyGroup xmlns="">
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\ -->
    <!--
        Condition intentionally omitted on this one, because it causes problems
        when we pick up the value of an environment variable named TargetDir
        -->
    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
    <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
    <!-- Example, C:\MyProjects\MyProject\ -->
    <ProjectDir Condition=" '$(ProjectDir)' == '' ">$([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))</ProjectDir>
    <!-- Example, C:\MyProjects\MyProject\MyProject.csproj -->
    <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- This is not used here but remains for backwards compatibility -->
    <AppConfigFileDestination Include="$(OutDir)$(TargetFileName).config" />
  </ItemGroup>
  <!--
    IDE Macros available only from integrated builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps. However, they are not defined when directly building
    a project from the command line, only when building a solution.
    -->
  <PropertyGroup xmlns="">
    <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
    <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
    <!-- Example, MySolution -->
    <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
    <!-- Example, MySolution.sln -->
    <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>
    <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
    <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>
    <!-- Example, f:\MySolutions\MySolution\ -->
    <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>
    <!-- Example, .sln -->
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <GenerateBindingRedirectsOutputType Condition="'$(OutputType)'=='exe' or '$(OutputType)'=='winexe'">true</GenerateBindingRedirectsOutputType>
    <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' &gt;= '4.7.2'">true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''" xmlns="">
    <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == '' and '$(DesignTimeBuild)' == 'true'">false</BuildProjectReferences>
    <!-- By default we will build (and if applicable, clean) all project references. But this can be used to disable that-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == ''">true</BuildProjectReferences>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
    <_ResolveReferenceDependencies Condition="'$(_ResolveReferenceDependencies)' == ''">false</_ResolveReferenceDependencies>
    <_GetChildProjectCopyToOutputDirectoryItems Condition="'$(_GetChildProjectCopyToOutputDirectoryItems)' == ''">true</_GetChildProjectCopyToOutputDirectoryItems>
    <OverwriteReadOnlyFiles Condition="'$(OverwriteReadOnlyFiles)' == ''">false</OverwriteReadOnlyFiles>
    <ComReferenceNoClassMembers Condition="'$(ComReferenceNoClassMembers)' == ''">false</ComReferenceNoClassMembers>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''" xmlns="">
    <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByAsciiChars($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
    <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" />
    <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')" />
    <CopyUpToDateMarker Include="$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildCopyMarkerName)'))" />
  </ItemGroup>
  <ItemGroup Condition="'$(ProduceReferenceAssembly)' == 'true'" xmlns="">
    <IntermediateRefAssembly Include="$(IntermediateOutputPath)refint\$(TargetName)$(TargetExt)" Condition="'@(IntermediateRefAssembly)' == ''" />
    <CreateDirectory Include="@(IntermediateRefAssembly->'%(RootDir)%(Directory)')" />
    <CreateDirectory Include="$(OutDir)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' == 'true'" />
    <CreateDirectory Include="$(IntermediateOutputPath)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' != 'true'" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true'" xmlns="">
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).compile.pdb" Condition="'$(OutputType)' == 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).pdb" Condition="'$(OutputType)' != 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''" xmlns="">
    <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''" xmlns="">
    <_IntermediateWindowsMetadataPath>$(IntermediateOutputPath)$(WinMDExpOutputWindowsMetadataFilename)</_IntermediateWindowsMetadataPath>
    <_WindowsMetadataOutputPath>$(OutDir)$(WinMDExpOutputWindowsMetadataFilename)</_WindowsMetadataOutputPath>
  </PropertyGroup>
  <!-- ARM64-related properties -->
  <PropertyGroup xmlns="">
    <_SupportedArchitectures>amd64 arm64</_SupportedArchitectures>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
    <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
      <TargetPath>$(TargetFileName)</TargetPath>
    </_DeploymentManifestEntryPoint>
    <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
    <!-- NOTE: The item Include and the Exists function are operating relative to the PROJECT (.csproj, .vbproj etc.) directory in this case -->
    <_DeploymentManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
      <TargetPath>$(ApplicationIcon)</TargetPath>
    </_DeploymentManifestIconFile>
    <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
    <ApplicationManifest Include="$(IntermediateOutputPath)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </ApplicationManifest>
    <!-- Create an item for the final application manifest (Example: WindowsApplication1.exe.manifeset)
             This item represents the final output application manifest used for project-to-project
             references and for copying to the publish output location. -->
    <_ApplicationManifestFinal Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </_ApplicationManifestFinal>
    <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
    <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
      <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
    </DeployManifest>
    <!-- Create an item for the intermediate trust info file -->
    <_DeploymentIntermediateTrustInfoFile Include="$(IntermediateOutputPath)$(TargetName).TrustInfo.xml" Condition="'$(TargetZone)'!=''" />
  </ItemGroup>
  <!--
    Determine the <deploymentProvider> (_DeploymentUrl) for the ClickOnce deployment manifest.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if not specified.
    If the UpdateUrl is specified then _DeploymentUrl is always set to the UpdateUrl.
    Otherwise, only set the _DeploymentUrl if it's an installed app and updates are enabled.
    -->
  <PropertyGroup xmlns="">
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(UpdateUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(InstallUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(PublishUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="!('$(UpdateUrl)'=='') and '$(Install)'=='false'" />
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'!=''">$(_DeploymentUrl)$(TargetDeployManifestFileName)</_DeploymentUrl>
    <!--
        Need to explicitly blank out the _DeploymentUrl when it's not used. Otherwise an
        inappropriate value may be used. For example a local path from the PublishUrl
        is something we never want to see in the manifest because it means you could
        only install the app from that machine.
        -->
    <_DeploymentUrl Condition="'$(UpdateUrl)'=='' and !('$(Install)'=='true' and '$(UpdateEnabled)'=='true')" />
    <_DeploymentUrl Condition="'$(ExcludeDeploymentUrl)'=='true'" />
  </PropertyGroup>
  <!-- Determine the URLs for the bootstrapper. -->
  <PropertyGroup xmlns="">
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</_DeploymentApplicationUrl>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true' and '$(InstallUrl)'==''">$(PublishUrl)</_DeploymentApplicationUrl>
    <_DeploymentComponentsUrl Condition="'$(BootstrapperComponentsLocation)'=='Absolute'">$(BootstrapperComponentsUrl)</_DeploymentComponentsUrl>
  </PropertyGroup>
  <!-- Output location for publish target. -->
  <PropertyGroup xmlns="">
    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
  </PropertyGroup>
  <!--
    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except
    for a trailing slash. PublishDir when specified as a global property on the command line cannot be changed to add a trailing slash.
  -->
  <PropertyGroup xmlns="">
    <ClickOncePublishDir>$(PublishDir)</ClickOncePublishDir>
    <ClickOncePublishDir Condition="!HasTrailingSlash('$(ClickOncePublishDir)')">$(ClickOncePublishDir)\</ClickOncePublishDir>
  </PropertyGroup>
  <!--
    ProcessorArchitecture is the target processor architecture.
    -->
  <PropertyGroup Condition="'$(ProcessorArchitecture)'==''" xmlns="">
    <!--
        If ProcessorArchitecture is not set, set it to PlatformTarget
        Note: if $(PlatformTarget) is also blank resolve assembly reference defaults to msil which is the
        desired behavior in this case
        -->
    <ProcessorArchitecture>$(PlatformTarget)</ProcessorArchitecture>
    <!--
        If Processor architecture is not set and PlatformTarget is a known target translate the
        PlatformTarget into something ResolveAssemblyReference knows about
        -->
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'AnyCpu' ">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x64' ">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x86' ">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'ARM' ">arm</ProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ConsiderPlatformAsProcessorArchitecture Condition="'$(ConsiderPlatformAsProcessorArchitecture)' == ''">true</ConsiderPlatformAsProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ProcessorArchitecture)' == '' and '$(ConsiderPlatformAsProcessorArchitecture)' == 'true'" xmlns="">
    <!-- We need to do this here because if we were to just compare against platform visual would parse them out as available platforms which may not be the case -->
    <ProcessorArchitectureAsPlatform>$(Platform)</ProcessorArchitectureAsPlatform>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'AnyCpu' or '$(ProcessorArchitectureAsPlatform)' == 'Any Cpu'">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x64' or '$(ProcessorArchitectureAsPlatform)' == 'amd64'">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x86' or '$(ProcessorArchitectureAsPlatform)' == 'win32'">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'ARM' ">arm</ProcessorArchitecture>
    <!--For compatibility with the 4.0 behavior, if not set above, default to the environment. To override this, set ProcessorArchitecture explicitly. We also need to disable the warning since we do not know if what the environment is set to is correct-->
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ProcessorArchitecture)'==''">None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
  </PropertyGroup>
  <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values. The Core runtime does not currently support specifying task architecture or runtime.
       If support for out-of-proc task execution is added on other runtimes, make sure each task's logic is checked against the current state of support. -->
  <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Full'" xmlns="">
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">CLR2</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v4.0' or '$(TargetFrameworkVersion)' == 'v4.5'">CLR4</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkAsMSBuildRuntime)' == ''">CurrentRuntime</TargetFrameworkAsMSBuildRuntime>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' != ''">true</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">false</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'x86' or ('$(PlatformTarget)' == 'x64' and '$(MSBuildExtensionsPath64)' != '')">$(PlatformTarget)</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'arm'">x86</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="('$(PlatformTarget)' == 'ia64' and '$(MSBuildExtensionsPath64)' != '')">x64</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">CurrentArchitecture</PlatformTargetAsMSBuildArchitecture>
  </PropertyGroup>
  <!-- Flavor is the project flavor. For example, Client, Smart Devices, SQL Server, etc. -->
  <PropertyGroup xmlns="">
    <ProjectFlavor Condition="'$(ProjectFlavor)'==''">Client</ProjectFlavor>
  </PropertyGroup>
  <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
  <PropertyGroup xmlns="">
    <DelaySign Condition="'$(SignAssembly)' != 'true'">false</DelaySign>
    <DelaySign Condition="'$(DelaySign)'!='true'" />
  </PropertyGroup>
  <!-- These properties control web reference proxy generation. -->
  <PropertyGroup xmlns="">
    <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
    <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
    <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
  </PropertyGroup>
  <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
  <PropertyGroup xmlns="">
    <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\$(TargetFrameworkIdentifier)</FrameworkRegistryBase>
    <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
    <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$([MSBuild]::GetToolsDirectory32())\AssemblyFolders.config</AssemblyFoldersConfigFile>
    <AssemblyFoldersConfigFileSearchPath Condition="Exists('$(AssemblyFoldersConfigFile)')">{AssemblyFoldersFromConfig:$(AssemblyFoldersConfigFile),$(TargetFrameworkVersion)};</AssemblyFoldersConfigFileSearchPath>
    <!--
        These are the extensions that assembly reference resolution will consider for resolution.
        Add new extensions here if you want to add new file types to consider (for example, .metadata_dll).
        Put the most likely extensions first for reference resolution speed.
        -->
    <AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
      .winmd;
      .dll;
      .exe
    </AllowedReferenceAssemblyFileExtensions>
    <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references.  Add new extensions here if you want to add new file types to consider.
        -->
    <AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
      .pdb;
      .xml;
      .pri;
      .dll.config;
      .exe.config
    </AllowedReferenceRelatedFileExtensions>
    <!--
        These names are used when determining which TargetFramework subset to use. If the any of the FullReferenceAssemblyNames
        are seen in the list of client subsets, RAR will assume that no client subset is being used. The list is semicolon seperated
        For example :   Full;Complete;AllThere
        -->
    <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
  </PropertyGroup>
  <PropertyGroup Condition="$(AssemblySearchPaths) == ''" xmlns="">
    <!--
        The SearchPaths property is set to find assemblies in the following order:

            (1) Files from current project - indicated by {CandidateAssemblyFiles}
            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
            (5) Assembly folders from AssemblyFolders.config file (provided by Visual Studio Dev15+).
            (6) Registered assembly folders, indicated by {Registry:*,*,*}
            (7) Legacy registered assembly folders, indicated by {AssemblyFolders}
            (8) Resolve to the GAC.
            (9) Treat the reference's Include as if it were a real file name.
            (10) Look in the application's output folder (like bin\debug)
        -->
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseReferencePath)' != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath)' != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRegistry)' != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFolders)' != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseGAC)' != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseOutDir)' != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
  </PropertyGroup>
  <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
         Default to ErrorAndStop, since that matches the behaviour in previous versions, and what users
         typically expect -->
  <PropertyGroup xmlns="">
    <ContinueOnError Condition="'$(ContinueOnError)' == ''">false</ContinueOnError>
  </PropertyGroup>
  <!-- Users familiar with how some other repos work try to use NoWarn with MSBuild in place of MSBuildWarningsAsMessages. -->
  <PropertyGroup xmlns="">
    <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
    <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
    <MSBuildWarningsNotAsErrors Condition="'$(MSBuildWarningsNotAsErrors)'==''">$(WarningsNotAsErrors)</MSBuildWarningsNotAsErrors>
  </PropertyGroup>
  <!-- Common Project System support -->
  <PropertyGroup xmlns="">
    <CommonXamlResourcesDirectory Condition=" '$(CommonXamlResourcesDirectory)' == '' ">$(MSBuildThisFileDirectory)$(LangName)\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <!-- We need to fallback to en-US in case the xaml rules are not localized (possibly happen on community languages).  -->
  <PropertyGroup Condition="!Exists('$(CommonXamlResourcesDirectory)')" xmlns="">
    <CommonXamlResourcesDirectory>$(MSBuildThisFileDirectory)en-US\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonItemSchemas)' == 'true' " xmlns="">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectItemsSchema.xaml" />
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)General.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Debugger_General.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General.BrowseObject.xaml">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General_File.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SCC.xaml">
      <Context>Invisible</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Folder.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)None.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Content.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)EmbeddedResource.xaml;&#xD;&#xA;                        ">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SpecialFolder.xaml;">
      <Context>File;ProjectSubscriptionService</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <PropertyGroup xmlns="">
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">$(DefineCommonItemSchemas)</DefineCommonReferenceSchemas>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonReferenceSchemas)' == 'true' " xmlns="">
    <!-- Assembly references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)assemblyreference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedAssemblyReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- COM references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)COMReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedCOMReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- Project references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedProjectReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' " xmlns="">
    <ProjectCapability Include="&#xD;&#xA;                          AssemblyReferences;&#xD;&#xA;                          COMReferences;&#xD;&#xA;                          ProjectReferences;&#xD;&#xA;                          SharedProjectReferences;&#xD;&#xA;                          OutputGroups;&#xD;&#xA;                          AllTargetOutputGroups;&#xD;&#xA;                          VisualStudioWellKnownOutputGroups;&#xD;&#xA;                          SingleFileGenerators;&#xD;&#xA;                          DeclaredSourceItems;&#xD;&#xA;                          UserSourceItems;&#xD;&#xA;                           " />
    <ProjectCapability Condition=" '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &lt; 8.0 " Include="BuildWindowsDesktopTarget" />
  </ItemGroup>
  <ItemDefinitionGroup Condition=" '$(DefineExplicitDefaults)' == 'true' " xmlns="">
    <None>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </None>
    <Content>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
    <Compile>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Compile>
    <EmbeddedResource>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
  </ItemDefinitionGroup>
  <!--
    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.

    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.

    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.

    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.

    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
    stored on the source control server.

    Source control information provider that sets these properties and items shall execute before this target (by including
    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
  -->
  <Target Name="InitializeSourceControlInformation" xmlns="" />
  <PropertyGroup xmlns="">
    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
  </PropertyGroup>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Build Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <Target Name="_AddOutputPathToGlobalPropertiesToRemove" xmlns="">
    <PropertyGroup>
      <_GlobalPropertiesToRemoveFromProjectReferences Condition="'$(PassOutputPathToReferencedProjects)'=='false'">$(_GlobalPropertiesToRemoveFromProjectReferences);OutputPath</_GlobalPropertiesToRemoveFromProjectReferences>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _CheckForInvalidConfigurationAndPlatform

    This target checks for errors in statically defined properties.  By setting BeforeTargets, we try
    to ensure that the target runs before any build related targets.
    If your target requires this check and is running as a BeforeTargets of one of the first targets
    of $(BuildDependsOn), $(RebuildDependsOn), or $(CleanDependsOn) you will need to set your DependsOn
    to this target.
    ============================================================
    -->
  <Target Name="_CheckForInvalidConfigurationAndPlatform" BeforeTargets="$(BuildDependsOn);Build;$(RebuildDependsOn);Rebuild;$(CleanDependsOn);Clean" xmlns="">
    <PropertyGroup>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' == 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingInsideVisualStudio</_InvalidConfigurationMessageResourceName>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' != 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingOutsideVisualStudio</_InvalidConfigurationMessageResourceName>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_InvalidConfigurationMessageSeverity)' != ''" ResourceName="$(_InvalidConfigurationMessageResourceName)" Severity="$(_InvalidConfigurationMessageSeverity)" FormatArguments="$(MSBuildProjectFile);$(_OriginalConfiguration);$(_OriginalPlatform)" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Configuration=$(Configuration)" Importance="Low" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Platform=$(Platform)" Importance="Low" />
    <!-- Although we try to ensure a trailing slash, it's possible to circumvent this if the property is set on the command line -->
    <MSBuildInternalMessage Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="OutDir" />
    <MSBuildInternalMessage Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="IntermediateOutputPath" />
    <MSBuildInternalMessage Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="BaseIntermediateOutputPath" />
    <!-- Also update the value of PlatformTargetAsMSBuildArchitecture per the value of Prefer32Bit.  We are doing
         this here because Prefer32Bit may be set anywhere in the targets, so we can't depend on it having the
         correct value when we're trying to figure out PlatformTargetAsMSBuildArchitecture -->
    <PropertyGroup Condition="'$(Prefer32Bit)' == 'true' and ('$(PlatformTarget)' == 'AnyCPU' or '$(PlatformTarget)' == '') and '$(PlatformTargetAsMSBuildArchitectureExplicitlySet)' != 'true'">
      <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>
    </PropertyGroup>
    <MSBuildInternalMessage Condition=" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.Prefer32BitAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.NoWin32ManifestAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' " ResourceName="CommonSdk.PlatformIsAnyCPUAndPreferNativeArm64Enabled" Severity="Warning" FormatArguments="$(Platform)" />
    <!--
      Log an error MSB3540 if the user set MSBuildProjectExtensionsPath in the body of a project. In an SDK style project
      if you set a value in the body, the value is not used by the top implicit import but is used by the bottom.
      This can lead to confusing behavior and builds can fail for obscure reasons.
    -->
    <MSBuildInternalMessage Condition=" '$(_InitialMSBuildProjectExtensionsPath)' != '' And '$(MSBuildProjectExtensionsPath)' != '$(_InitialMSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.MSBuildProjectExtensionsPathModifiedAfterUse" Severity="Error" />
    <!--
      Log a warning MSB3539 if:
        1. $(EnableBaseIntermediateOutputPathMismatchWarning) is 'true'
        2. $(BaseIntermediateOutputPath) was set in the body of a project after its default value was set in Microsoft.Common.props
        3. $(BaseIntermediateOutputPath) is not the same as $(MSBuildProjectExtensionsPath)

      Similar to the error above, there are cases when users set $(BaseIntermediateOutputPath) in the body of their project and things build but only by coincidence.
      MSBuild does not know if $(BaseIntermediateOutputPath) changing would cause problems so tools like NuGet must set $(EnableBaseIntermediateOutputPathMismatchWarning)
      to 'true'.
    -->
    <MSBuildInternalMessage Condition=" '$(EnableBaseIntermediateOutputPathMismatchWarning)' == 'true' And '$(_InitialBaseIntermediateOutputPath)' != '$(BaseIntermediateOutputPath)' And '$(BaseIntermediateOutputPath)' != '$(MSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.BaseIntermediateOutputPathMismatchWarning" Severity="Warning" />
  </Target>
  <!--
    ============================================================
                                        Build

    The main build entry point.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildDependsOn>
      BeforeBuild;
      CoreBuild;
      AfterBuild
    </BuildDependsOn>
  </PropertyGroup>
  <Target Name="Build" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(BuildDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="" />
  <!--
    ============================================================
                                        BeforeBuild

    Redefine this target in your project in order to run tasks just before Build
    ============================================================
    -->
  <Target Name="BeforeBuild" xmlns="" />
  <!--
    ============================================================
                                        AfterBuild

    Redefine this target in your project in order to run tasks just after Build
    ============================================================
    -->
  <Target Name="AfterBuild" xmlns="" />
  <!--
    ============================================================
                                        CoreBuild

    The core build step calls each of the build targets.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      Compile;
      ExportWindowsMDFile;
      UnmanagedUnregistration;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
      GenerateManifests;
      GetTargetPath;
      PrepareForRun;
      UnmanagedRegistration;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>
  <Target Name="CoreBuild" DependsOnTargets="$(CoreBuildDependsOn)" xmlns="">
    <OnError ExecuteTargets="_TimeStampAfterCompile;PostBuildEvent" Condition="'$(RunPostBuildEvent)'=='Always' or '$(RunPostBuildEvent)'=='OnOutputUpdated'" />
    <OnError ExecuteTargets="_CleanRecordFileWrites" />
  </Target>
  <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
    <RebuildDependsOn>
      BeforeRebuild;
      Clean;
      $(_ProjectDefaultTargets);
      AfterRebuild;
    </RebuildDependsOn>
    <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' ">
      BeforeRebuild;
      Clean;
      Build;
      AfterRebuild;
    </RebuildDependsOn>
  </PropertyGroup>
  <Target Name="Rebuild" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(RebuildDependsOn)" Returns="$(TargetPath)" xmlns="" />
  <!--
    ============================================================
                                        BeforeRebuild

    Redefine this target in your project in order to run tasks just before Rebuild
    ============================================================
    -->
  <Target Name="BeforeRebuild" xmlns="" />
  <!--
    ============================================================
                                        AfterRebuild

    Redefine this target in your project in order to run tasks just after Rebuild
    ============================================================
    -->
  <Target Name="AfterRebuild" xmlns="" />
  <!--
    ============================================================
                                        BuildGenerateSources

    Redefine this target in your project in order to run tasks for BuildGenerateSources

    Set BuildPassReferences to enable P2P builds
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildGenerateSourcesAction>Build</BuildGenerateSourcesAction>
  </PropertyGroup>
  <Target Name="BuildGenerateSources" DependsOnTargets="BuildGenerateSourcesTraverse;$(BuildGenerateSourcesAction)" xmlns="" />
  <Target Name="BuildGenerateSourcesTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildGenerateSources" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework);" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildGenerateSources" Targets="BuildGenerateSources" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildCompile

    Redefine this target in your project in order to run tasks for BuildCompile
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildCompileAction>Build</BuildCompileAction>
  </PropertyGroup>
  <Target Name="BuildCompile" DependsOnTargets="BuildCompileTraverse;$(BuildCompileAction)" xmlns="" />
  <Target Name="BuildCompileTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildCompile" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildCompile" Targets="BuildCompile" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildLink

    Redefine this target in your project in order to run tasks for BuildLink
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildLinkAction>Build</BuildLinkAction>
  </PropertyGroup>
  <Target Name="BuildLink" DependsOnTargets="BuildLinkTraverse;$(BuildLinkAction)" xmlns="" />
  <Target Name="BuildLinkTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildLink" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildLink" Targets="BuildLink" />
  </ItemGroup>
  <!--
    ============================================================
                                        CopyRunEnvironmentFiles

    Copy environment files necessary to run the user's app to the final directory.
    This is a public target that can be invoked by an IDE.

    This may be used by an IDE to make the app.config file available for running
    the target app.
    ============================================================
    -->
  <Target Name="CopyRunEnvironmentFiles" DependsOnTargets="PrepareForBuild;SetWin32ManifestProperties;_CopyAppConfigFile;_CleanRecordFileWrites" xmlns="" />
  <!--
    ============================================================
                                        Run

    Run the final build output if it is a .EXE
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <RunDependsOn />
  </PropertyGroup>
  <Target Name="Run" DependsOnTargets="$(RunDependsOn)" xmlns="">
    <MSBuildInternalMessage Condition="'$(TargetExt)'!='.exe'" ResourceName="CommonSdk.RunTargetDependsOnMessage" Severity="Error" FormatArguments="$(TargetPath)" />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(OutDir)" Condition=" '$(StartWorkingDirectory)' == '' " />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(StartWorkingDirectory)" Condition=" '$(StartWorkingDirectory)' != '' " />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                BuildOnlySettings Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        BuildOnlySettings

    This target is called only when doing a real build.  It is specifically not called during project load.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildingProject>false</BuildingProject>
  </PropertyGroup>
  <Target Name="BuildOnlySettings" xmlns="">
    <PropertyGroup>
      <BuildingProject>true</BuildingProject>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForBuild Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareForBuild

    Prepare the prerequisites for building.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)" xmlns="">
    <ItemGroup>
      <AppConfigWithTargetPath Include="$(AppConfig)" Condition="'$(AppConfig)'!=''">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
    <FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config" Condition="'$(AppConfig)'==''">
      <Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath" />
      <Output TaskParameter="AppConfigFile" PropertyName="AppConfig" />
    </FindAppConfigFile>
    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="true" />
  </Target>
  <!--
    ============================================================
                                        GetFrameworkPaths

    Get the paths for the .NET Framework installation directory

    These paths are not used directly by this .targets file but are available for pre and
    post build steps.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <Framework40Dir>@(_TargetFramework40DirectoryItem)</Framework40Dir>
    <Framework35Dir>@(_TargetFramework35DirectoryItem)</Framework35Dir>
    <Framework30Dir>@(_TargetFramework30DirectoryItem)</Framework30Dir>
    <Framework20Dir>@(_TargetFramework20DirectoryItem)</Framework20Dir>
    <!-- Note we need to make the 4.0 FrameworkDir point to the 2.0 location by default since we shipped msbuild 4.0 that way and to change it would be a breaking change.-->
    <FrameworkDir Condition="'$(FrameworkDir)' == '' and ('$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0')">@(_TargetFramework20DirectoryItem)</FrameworkDir>
    <FrameworkDir Condition="'$(FrameworkDir)' == ''">@(_TargetFramework40DirectoryItem)</FrameworkDir>
    <TargetedFrameworkDir Condition="'$(TargetedFrameworkDir)' == ''">@(_TargetedFrameworkDirectoryItem)</TargetedFrameworkDir>
    <FrameworkSDKDir Condition="'$(FrameworkSDKDir)' == ''">@(_TargetFrameworkSDKDirectoryItem)</FrameworkSDKDir>
    <GetFrameworkPathsDependsOn />
  </PropertyGroup>
  <!-- This is a generally overriden target, for example it is overriden in the Microsoft.NETFramework.targets file -->
  <Target Name="GetFrameworkPaths" xmlns="" />
  <!--
    ============================================================
                                        GetReferenceAssemblyPaths

    Get the paths for the Reference Assemblies for the known versions of the
    .NET Framework.

    These paths are used by the build process in order to resolve the correct
    assemblies from the various directories, and to support multi-targeting
    ============================================================
    -->
  <Target Name="GetReferenceAssemblyPaths" DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn);GetFrameworkPaths" xmlns="">
    <!-- if TargetFrameworkDirectory doesn't have a custom value, clear it out; that way we can get reference paths and target framework directories all in the right order -->
    <PropertyGroup>
      <TargetFrameworkDirectory Condition="'@(_CombinedTargetFrameworkDirectoriesItem)' == '$(TargetFrameworkDirectory)'" />
    </PropertyGroup>
    <!-- By default if there is no root path set then the task will assume it is Program Files\Reference Assemblies\Microsoft\Framework-->
    <GetReferenceAssemblyPaths Condition="'$(TargetFrameworkMoniker)' != '' and ('$(_TargetFrameworkDirectories)' == '' or '$(_FullFrameworkReferenceAssemblyPaths)' == '')" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories" />
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
      <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <TargetFrameworkDirectory>$(_TargetFrameworkDirectories);$(TargetFrameworkDirectory);$(WinFXAssemblyDirectory)</TargetFrameworkDirectory>
      <TargetFrameworkDirectory Condition="'$(TargetPlatformWinMDLocation)' != '' and Exists('$(TargetPlatformWinMDLocation)')">$(TargetFrameworkDirectory);$(TargetPlatformWinMDLocation)</TargetFrameworkDirectory>
    </PropertyGroup>
    <!-- Remove the AssemblyFolders if no target framework directories could be found. This is to prevent us from
             resolving from the assemblyfolders global location if we are not acutally targeting a framework-->
    <PropertyGroup>
      <RemoveAssemblyFoldersIfNoTargetFramework Condition="'$(RemoveAssemblyFoldersIfNoTargetFramework)' == ''">true</RemoveAssemblyFoldersIfNoTargetFramework>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == '' and '$(AssemblySearchPaths)' != '' and '$(RemoveAssemblyFoldersIfNoTargetFramework)' == 'true'">
      <AssemblySearchPaths>$(AssemblySearchPaths.Replace('{AssemblyFolders}', '').Split(';'))</AssemblySearchPaths>
    </PropertyGroup>
    <ItemGroup Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'">
      <DesignTimeFacadeDirectoryRoots Include="$(TargetFrameworkDirectory)" />
      <DesignTimeFacadeDirectories Include="%(DesignTimeFacadeDirectoryRoots.Identity)Facades\" Condition="Exists('%(DesignTimeFacadeDirectoryRoots.Identity)Facades\')" />
    </ItemGroup>
    <PropertyGroup Condition="'@(DesignTimeFacadeDirectories)' != ''">
      <TargetFrameworkDirectory>$(TargetFrameworkDirectory);@(DesignTimeFacadeDirectories)</TargetFrameworkDirectory>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
      <TargetFrameworkProfile />
    </PropertyGroup>
  </Target>
  <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
  <Target Name="GetTargetFrameworkMoniker" Returns="$(TargetFrameworkMoniker)" xmlns="" />
  <!-- Returns target framework moniker display name. E.g. ".NET Framework 4 Platform Update 1 (KB2478063)" -->
  <Target Name="GetTargetFrameworkMonikerDisplayName" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkMonikerDisplayName)" xmlns="" />
  <!-- Returns semicolon separated list of target framework directories.
  E.g "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0.1\;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\" -->
  <Target Name="GetTargetFrameworkDirectories" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkDirectory)" xmlns="" />
  <!--
    ============================================================
                                        AssignLinkMetadata

       For items of a certain set of allowlisted types, make sure that
       if they are defined in a file other than the project file, that
       they have "Link" metadata set to an appropriate default.
    ============================================================
    -->
  <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' " xmlns="">
    <!-- NONE ITEMS -->
    <AssignLinkMetadata Items="@(None)" Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <None Remove="@(_Temp)" />
      <None Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- CONTENT ITEMS -->
    <AssignLinkMetadata Items="@(Content)" Condition="'@(Content)' != '' and '%(Content.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Content Remove="@(_Temp)" />
      <Content Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- PAGE ITEMS -->
    <AssignLinkMetadata Items="@(Page)" Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Page Remove="@(_Temp)" />
      <Page Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- APPLICATIONDEFINITION ITEMS -->
    <AssignLinkMetadata Items="@(ApplicationDefinition)" Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <ApplicationDefinition Remove="@(_Temp)" />
      <ApplicationDefinition Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- EMBEDDEDRESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(EmbeddedResource)" Condition="'@(EmbeddedResource)' != '' and '%(EmbeddedResource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temp)" />
      <EmbeddedResource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- RESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(Resource)" Condition="'@(Resource)' != '' and '%(Resource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)' and $([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup Condition="$([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Resource Remove="@(_Temp)" />
      <Resource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PreBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PreBuildEvent

    Run the pre-build event if there is one.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PreBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PreBuildEvent" Condition="'$(PreBuildEvent)'!=''" DependsOnTargets="$(PreBuildEventDependsOn)" xmlns="">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedUnregistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedUnregistration

    If the main assembly had previously been registered for COM interop, unregister it now.
    We will re-register the new version after it has been built.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <UnmanagedUnregistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedUnregistration" Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or&#xD;&#xA;                    ('$(_AssemblyTimestampBeforeCompile)' == '')) and&#xD;&#xA;                   Exists('@(_UnmanagedRegistrationCache)')" DependsOnTargets="$(UnmanagedUnregistrationDependsOn)" xmlns="">
    <PropertyGroup>
      <UnregisterAssemblyMSBuildArchitecture Condition="'$(UnregisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</UnregisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(UnregisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(UnregisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</UnregisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)" MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)" MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveReferences Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                     GetTargetFrameworkVersion

    This stand-alone target returns the target framework version (i.e. v3.5, v4.0, etc.)
    that would be used if we built this project.

    ============================================================
    -->
  <Target Name="GetTargetFrameworkVersion" Returns="$(TargetFrameworkVersion)" xmlns="" />
  <!--
    ============================================================
                                        ResolveReferences
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResolveReferencesDependsOn>
      BeforeResolveReferences;
      AssignProjectConfiguration;
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      ResolveNativeReferences;
      ResolveAssemblyReferences;
      GenerateBindingRedirects;
      GenerateBindingRedirectsUpdateAppConfig;
      ResolveComReferences;
      AfterResolveReferences
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveReferencesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeResolveReferences

    Redefine this target in your project in order to run tasks just before ResolveReferences
    ============================================================
    -->
  <Target Name="BeforeResolveReferences" xmlns="" />
  <!--
    ============================================================
                                        AfterResolveReferences

    Redefine this target in your project in order to run tasks just after ResolveReferences
    ============================================================
    -->
  <Target Name="AfterResolveReferences" xmlns="" />
  <!--
    ============================================================
                                        IgnoreJavaScriptOutputAssembly

    esproj are JavaScript or TypeScript Projects that never produce an assembly.
    Set ReferenceOutputAssembly to false in any reference to an esproj.
    ============================================================
    -->
  <Target Name="IgnoreJavaScriptOutputAssembly" BeforeTargets="AssignProjectConfiguration" xmlns="">
    <ItemGroup>
      <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
        <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
      </ProjectReference>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        AssignProjectConfiguration

    Assigns the appropriate configuration to each project in the list of project references passed in.
    Adds to the project references passed in any project references implied by dependencies expressed in the solution file, if any.

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(ProjectReferenceWithConfiguration) - the list of project references (MSBuild and potentially VSIP projects)
                                               with metadata values FullConfiguration, Configuration, Platform,
                                               SetConfiguration, and SetPlatform
    ============================================================
    -->
  <Target Name="AssignProjectConfiguration" Condition="'$(CurrentSolutionConfigurationContents)' != '' or '@(ProjectReference)'!=''" xmlns="">
    <PropertyGroup>
      <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration Condition="'$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)' == ''">true</OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildingSolutionFile)' == 'true')">true</ShouldUnsetParentConfigurationAndPlatform>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == ''">false</ShouldUnsetParentConfigurationAndPlatform>
      <!-- Web Application projects can "secretly" reference Silverlight projects, which can take project dependencies on that same Web Application.  If the project
           dependencies are promoted to project references, this ends up creating a situation where we have a circular reference between the two projects.  We don't
           want this to happen, so just turn off synthetic project reference generation for Silverlight projects. -->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(TargetFrameworkIdentifier)' == 'Silverlight'">false</AddSyntheticProjectReferencesForSolutionDependencies>
      <!-- Inside VS, we do not need to add synthetic references, as VS already organizes the build per any solution-level dependencies; we only do this on the command line-->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</AddSyntheticProjectReferencesForSolutionDependencies>
    </PropertyGroup>
    <!-- Assign a project configuration to each project reference if we're building a solution file. -->
    <AssignProjectConfiguration ProjectReferences="@(ProjectReference)" CurrentProject="$(MSBuildProjectFullPath)" CurrentProjectConfiguration="$(Configuration)" CurrentProjectPlatform="$(Platform)" DefaultToVcxPlatformMapping="$(DefaultToVcxPlatformMapping)" VcxToDefaultPlatformMapping="$(VcxToDefaultPlatformMapping)" OutputType="$(OutputType)" ResolveConfigurationPlatformUsingMappings="false" SolutionConfigurationContents="$(CurrentSolutionConfigurationContents)" AddSyntheticProjectReferencesForSolutionDependencies="$(AddSyntheticProjectReferencesForSolutionDependencies)" OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration="$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)" ShouldUnsetParentConfigurationAndPlatform="$(ShouldUnsetParentConfigurationAndPlatform)">
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME PROJECTREFERENCEWITHCONFIGURATION INSTEAD -->
      <Output TaskParameter="AssignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="AssignedProjects" ItemName="ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="ProjectReferenceWithConfiguration" />
    </AssignProjectConfiguration>
    <ItemGroup>
      <_ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(_ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(_ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </_ProjectReferenceWithConfiguration>
      <ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </ProjectReferenceWithConfiguration>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SplitProjectReferencesByFileExistence

    Split referenced projects into two lists: those that exist on
    disk and those that don't.
    ============================================================
    -->
  <Target Name="_SplitProjectReferencesByFileExistence" xmlns="">
    <!--
        Use this task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE.  The IDE only includes non-MSBuild projects in the output list.  We'll
        use MSBuild to resolve MSBuild projects.
        This task will resolve VSIP (3rd party) project references and create a new item list with only project references
        to projects in the MSBuild format.
        -->
    <ResolveNonMSBuildProjectOutput ProjectReferences="@(ProjectReferenceWithConfiguration)" PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)" Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(ProjectReferenceWithConfiguration)'!=''">
      <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedProjectReferencePaths" />
      <Output TaskParameter="UnresolvedProjectReferences" ItemName="_MSBuildProjectReference" />
    </ResolveNonMSBuildProjectOutput>
    <!--
       If building from the command line, simply copy the ProjectReferenceWithConfiguration item list to _MSBuildProjectReference,
       since we have to assume all projects are in the MSBuild format. We have no way of building
       VSIP (3rd party) projects from the command line.
       -->
    <ItemGroup>
      <_MSBuildProjectReference Include="@(ProjectReferenceWithConfiguration)" Condition="'$(BuildingInsideVisualStudio)'!='true' and '@(ProjectReferenceWithConfiguration)'!=''" />
    </ItemGroup>
    <!-- Break the project list into two lists: those that exist on disk and those that don't. -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Include="@(_MSBuildProjectReference)" Condition="Exists('%(Identity)')" />
      <_MSBuildProjectReferenceNonexistent Include="@(_MSBuildProjectReference)" Condition="!Exists('%(Identity)')" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferencePlatformProperties

    If a project is opted in via $(EnableDynamicPlatformResolution), this target calls the
    GetCompatiblePlatform task on all ProjectReference items to determine the most compatible
    platform for each project. It then sets SetPlatform metadata on each ProjectReference.
    This prevents overbuilding a project when 'AnyCPU' is available.

    ======================================================================================
  -->
  <PropertyGroup xmlns="">
    <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
  </PropertyGroup>
  <!-- This target skips sln-based builds because they already supply Platform and
       Configuration information. See AssignProjectConfiguration -->
  <Target Name="_GetProjectReferencePlatformProperties" Condition="'$(EnableDynamicPlatformResolution)' == 'true'&#xD;&#xA;                     and '@(_MSBuildProjectReferenceExistent)' != ''" xmlns="">
    <!-- Allow preset SetPlatform to override this operation -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''">
        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <ItemGroup>
      <_ProjectReferencePlatformPossibilities Include="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
    </ItemGroup>
    <!-- Assign default PlatformLookupTables when doing Managed <-> Unmanaged hops -->
    <ItemGroup>
      <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'">
        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">x86=Win32</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
      <!-- If we're looking at a managed project from a cpp project, map native to managed platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj') and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' != 'true'">
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">Win32=x86</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
    </ItemGroup>
    <GetCompatiblePlatform AnnotatedProjects="@(_ProjectReferencePlatformPossibilities)" CurrentProjectPlatform="$(Platform)" PlatformLookupTable="$(PlatformLookupTable)" Condition="'@(_ProjectReferencePlatformPossibilities)' != ''">
      <Output ItemName="_ProjectsWithPlatformAssignment" TaskParameter="AssignedProjectsWithPlatform" />
    </GetCompatiblePlatform>
    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.
         Don't do anything in this case. Ex: A project references many projects
         that can't multiplatform.  -->
    <ItemGroup Condition="'@(_ProjectsWithPlatformAssignment)' != ''">
      <ProjectsWithNearestPlatform Include="@(_ProjectsWithPlatformAssignment)" />
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''">
        <SetPlatform>Platform=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
      </ProjectsWithNearestPlatform>
      <!-- When GetCompatiblePlatform fails to assign NearestPlatform (or determines it's identical to default for the referenced project), undefine Platform and let that project build "on its own" -->
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' == ''">
        <UndefineProperties>%(ProjectsWithNearestPlatform.UndefineProperties);Platform</UndefineProperties>
      </ProjectsWithNearestPlatform>
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(ProjectsWithNearestPlatform)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferenceTargetFrameworkProperties

    Builds the GetTargetFrameworks target of all existent project references to get a list
    of all supported TargetFrameworks of the referenced projects. Calls the
    GetReferenceNearestTargetFrameworkTask to determine the closest match for each project.
    This allows a cross-targeting project to select how it should be configured to build
    against the most appropriate target for the referring target framework.

    ======================================================================================
  -->
  <Target Name="_GetProjectReferenceTargetFrameworkProperties" DependsOnTargets="_AddOutputPathToGlobalPropertiesToRemove" xmlns="">
    <!--
      Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over
      TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and
      has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild
      invocation below to fail by passing invalid properties. Therefore we do not use the NTM if it contains a semicolon.
    -->
    <PropertyGroup Condition="'$(ReferringTargetFrameworkForProjectReferences)' == ''">
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' != '' and !$(NuGetTargetMoniker.Contains(';'))">$(NuGetTargetMoniker)</ReferringTargetFrameworkForProjectReferences>
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' == ''">$(TargetFrameworkMoniker)</ReferringTargetFrameworkForProjectReferences>
    </PropertyGroup>
    <!--
      Honor SkipGetTargetFrameworkProperties=true metadata on project references
      to mean that the project reference is known not to target multiple frameworks
      and the mechanism here for selecting the best one can be skipped as an optimization.

      We give this treatment to .vcxproj by default since no .vcxproj can target more
      than one framework currently. The user must specify exactly one TargetFramework.

      vcxproj files compile down to OS-specific binaries, either native or .NET. In the
      _GetProjectReferenceTargetFrameworkProperties target of Microsoft.Common.CurrentVersion.targets,
      SkipTargetFrameworkProperties is set to true for vcxproj to account for that.

      This means we do not fill the Item _ProjectReferenceTargetFrameworkPossibilities or, by extension,
      the AnnotatedProjects Item.

      For single-targeted projects, we normally decorate the AnnotatedProjects Item with
      UndefineProperties metadata specifying that TargetFramework should be undefined. Because it
      isn't defined properly at that stage, however, this does not happen, and TargetFramework is
      defined at this point in addition to having been defined globally. Currently, this is always
      true for vcxproj.

      MSBuild permits building the same project twice as long as it has different sets of global properties.
      Because the TargetFramework global property is not being removed as expected by the multitargeting
      part of MSBuild, the engine recognizes that there are differences and builds it twice. This can
      become more noticeable if the projects build in parallel, since they could try to access the same
      resources and conflict, failing the build. Note, however, that building the same project twice in
      this way is always wrong even if it seems minor because they do not conflict, and the second build is
      relatively fast.
   -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
        <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Allow project references to specify which target framework properties to set and their values
       without consulting the referenced project. This has two use cases:

       1. A caller may wish to pick a compatible but sub-optimal target framework. For example,
          to unit test the .NETStandard implementation using a .NETFramework caller even though
          there is also a .NETFramework implementation.

       2. As an escape hatch for cases where the compatibility check performed by
          GetTargetFrameworkProperties is faulty.
    -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Get reference target framework lists.
       Note: A future optimization could cache the closest match and set the target framework on
       this MSBuild task invocation. This would (optimistically) save an evaluation of the referenced
       project when the answer is the same.
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <!--
       SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
       whether or not the referenced project would build as the same platform as the current project by default. The above
       MSBuild call is kept for legacy scenarios that may depend on passing %(SetConfiguration) and %(SetPlatform).
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <ItemGroup>
      <!--
        Preserve the ItemSpec value on the _ProjectReferenceTargetFrameworkPossibilities. Because relative paths in another project
        context would be incorrect, the MSBuild task invocation needs expands the project reference paths in the MSBuild task above.
        This is generally OK, but if the list is copied the OriginalItemSpec can become the expanded value and cause issues correlating
        a project reference back to an Item instance.
      -->
      <_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec Include="@(_ProjectReferenceTargetFrameworkPossibilities->'%(OriginalItemSpec)')" />
      <_ProjectReferenceTargetFrameworkPossibilities Remove="@(_ProjectReferenceTargetFrameworkPossibilities)" />
      <_ProjectReferenceTargetFrameworkPossibilities Include="@(_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec)" />
    </ItemGroup>
    <!-- For each reference, get closest match -->
    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
         that we are using a version of NuGet which supports that parameter on this task. -->
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectTargetPlatform="$(TargetPlatformMoniker)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xD;&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xD;&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <ItemGroup>
      <!--
         If the task was skipped or the current TargetFramework is empty, AnnotatedProjects will be empty.
         In this case, copy _ProjectReferenceTargetFrameworkPossibilities as is. See:
            https://github.com/dotnet/sdk/issues/416

        Furthermore, if we're referencing a .vcxproj or .nativeproj, those items won't be populated into `AnnotatedProjects`
        by `GetReferenceNearestTargetFrameworkTask`, so let them flow when `EnableDynamicPlatformResolution` is set.
      -->
      <AnnotatedProjects Include="@(_ProjectReferenceTargetFrameworkPossibilities)" Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or&#xD;&#xA;                                    ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
    </ItemGroup>
    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.
         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects
         the IsRidAgnostic value for the NearestTargetFramework for the project. -->
    <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
      <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
    </SetRidAgnosticValueForProjects>
    <ItemGroup>
      <AnnotatedProjects Remove="@(AnnotatedProjects)" />
      <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
      <UpdatedAnnotatedProjects Remove="@(UpdatedAnnotatedProjects)" />
      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
        <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
      </AnnotatedProjects>
      <!--
         If the NearestTargetFramework property was not set or the project has a single TargetFramework, we need to Undefine
         TargetFramework to avoid another project evaluation.
      -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and ('%(AnnotatedProjects.NearestTargetFramework)' == '' or '%(AnnotatedProjects.HasSingleTargetFramework)' == 'true')">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>
      </AnnotatedProjects>
      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,
           unless the project is expecting those properties to flow. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier;SelfContained</UndefineProperties>
      </AnnotatedProjects>
      <!--
         Remove the items we've touched from _MSBuildProjectReferenceExistent. This will leave all projects where
         SkipGetTargetFrameworkProperties was set. Then add all AnnotatedProjects back.
      -->
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(AnnotatedProjects)" />
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworks" DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_ThisProjectBuildMetadata)" xmlns="">
    <MSBuildInternalMessage Condition="'$(IsCrossTargetingBuild)' == 'true'" ResourceName="CommonSdk.CrossTargetingGetTargetFrameworks" Severity="Error" />
    <CombineXmlElements RootElementName="AdditionalProjectProperties" XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
      <Output TaskParameter="Result" PropertyName="_AdditionalPropertiesFromProject" />
    </CombineXmlElements>
    <ItemGroup>
      <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
        <HasSingleTargetFramework>true</HasSingleTargetFramework>
        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
        <!-- Extract necessary information for SetPlatform negotiation -->
        <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
        <Platform>$(Platform)</Platform>
        <Platforms>$(Platforms)</Platforms>
        <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
             Build the `Platforms` property from that. -->
        <Platforms Condition="'$(UsePlatformFromProjectConfiguration)' != 'false' and '@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration-&gt;'%(Platform)'-&gt;Distinct())</Platforms>
      </_ThisProjectBuildMetadata>
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_TargetFrameworkInfo)" xmlns="">
    <ItemGroup>
      <_AdditionalTargetFrameworkInfoPropertyWithValue Include="@(AdditionalTargetFrameworkInfoProperty)">
        <Value>$(%(AdditionalTargetFrameworkInfoProperty.Identity))</Value>
      </_AdditionalTargetFrameworkInfoPropertyWithValue>
    </ItemGroup>
    <PropertyGroup>
      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
    </PropertyGroup>
    <CombineTargetFrameworkInfoProperties RootElementName="$(TargetFramework)" PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)" UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
      <Output TaskParameter="Result" PropertyName="_AdditionalTargetFrameworkInfoProperties" />
    </CombineTargetFrameworkInfoProperties>
    <ItemGroup>
      <_TargetFrameworkInfo Include="$(TargetFramework)">
        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
        <!-- Determine whether a project is "RID agnostic" for each TargetFramework.  "RID agnostic" means that global properties such as
             SelfContained and RuntimeIdentifier should not flow across project references.  The IsRidAgnostic metadata value is consumed in the
             _GetProjectReferenceTargetFrameworkProperties target, where those properties are added to a project's UndefineProperties if
             IsRidAgnostic is set.

             Generally we set the IsRidAgnostic metadata based on the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the
             fallback logic here will be that the project is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == ''">false</IsRidAgnostic>
      </_TargetFrameworkInfo>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                    GetTargetFrameworkProperties

    OBSOLETE: present only for theoretical backward compatibility.
  -->
  <Target Name="GetTargetFrameworkProperties" xmlns="" />
  <!--
    ============================================================
                                        PrepareProjectReferences

    Prepares project references for consumption by other targets.

        [IN]
        @(ProjectReference) - The list of project references.

        [OUT]
        @(ProjectReferenceWithConfiguration)   - Project references with apporpriate metadata
        @(_MSBuildProjectReferenceExistent)    - Subset of @(ProjectReferenceWithConfiguration) that exist
                                                 with added SetTargetFramework metadata for cross-targeting
        @(_MSBuildProjectReferenceNonExistent) - Subset of  @(ProjectReferenceWithConfiguration) that do not exist
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <PrepareProjectReferencesDependsOn>
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _GetProjectReferenceTargetFrameworkProperties;
      _GetProjectReferencePlatformProperties
    </PrepareProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareProjectReferences" DependsOnTargets="$(PrepareProjectReferencesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        ResolveProjectReferences

    Build referenced projects:

        [IN]
        @(ProjectReferenceWithConfiguration) - The list of project references.

        [OUT]
        @(_ResolvedNativeProjectReferencePaths) - Paths to referenced native projects.
        @(_ResolvedProjectReferencePaths) - Paths to referenced managed projects.
    ============================================================
    -->
  <!-- By default, the outputs of project references are passed to the compiler -->
  <ItemDefinitionGroup xmlns="">
    <ProjectReference>
      <!-- Target to build in the project reference; by default, this property is blank, indicating the default targets-->
      <Targets>$(ProjectReferenceBuildTargets)</Targets>
      <!-- Extra item type to emit outputs of the destination into. Defaults to blank. To emit only into this list, set the ReferenceOutputAssembly metadata to false as well. -->
      <OutputItemType />
      <ReferenceSourceTarget>ProjectReference</ReferenceSourceTarget>
    </ProjectReference>
  </ItemDefinitionGroup>
  <Target Name="ResolveProjectReferences" DependsOnTargets="PrepareProjectReferences" Returns="@(_ResolvedNativeProjectReferencePaths);@(_ResolvedProjectReferencePaths)" xmlns="">
    <!--
        When building this project from the IDE, just gather the referenced build outputs.
        The IDE will already have built the project, so there's no need to do it again here.

        The ContinueOnError setting is here so that, during project load, as
        much information as possible will be passed to the compilers.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetPath" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Build referenced projects when building from the command line.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="%(_MSBuildProjectReferenceExistent.Targets)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetNativeManifest" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="NativeReference" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)' == 'true'" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ResolveableAssembly)' == 'false'" />
      <!--
          Copy OriginalItemSpec to OriginalProjectReferenceItemSpec, so that when ResolveAssemblyReferences
          takes these items and resolves them to ReferencePath, we can still recover the _real_ OriginalItemSpec
          for the unresolved reference items.
          -->
      <_ResolvedProjectReferencePaths>
        <OriginalProjectReferenceItemSpec>%(_ResolvedProjectReferencePaths.OriginalItemSpec)</OriginalProjectReferenceItemSpec>
      </_ResolvedProjectReferencePaths>
    </ItemGroup>
    <!-- Issue a warning or error MSB9008 for each non-existent project. -->
    <PropertyGroup>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' != 'True'">Warning</_NonExistentProjectReferenceSeverity>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' == 'True'">Error</_NonExistentProjectReferenceSeverity>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_NonExistentProjectReferenceSeverity)' != ''" ResourceName="CommonSdk.NonExistentProjectReference" Severity="$(_NonExistentProjectReferenceSeverity)" FormatArguments="@(_MSBuildProjectReferenceNonexistent->'%(Identity)')" />
  </Target>
  <Target Name="ResolveProjectReferencesDesignTime" Returns="@(_ProjectReferencesFromRAR);@(_ResolvedNativeProjectReferencePaths)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences" xmlns="">
    <!-- We need to do this here because we only want project references which have passed through rar and have not been unresolved due to violating some MT rule
        which means we need to pull the project references out of the referencepath item because they will only exist there if they were correctly resolved.
    -->
    <ItemGroup>
      <_ProjectReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))">
        <OriginalItemSpec>%(ReferencePath.ProjectReferenceOriginalItemSpec)</OriginalItemSpec>
      </_ProjectReferencesFromRAR>
    </ItemGroup>
  </Target>
  <Target Name="ExpandSDKReferencesDesignTime" Returns="@(ReferencesFromSDK)" DependsOnTargets="ExpandSDKReferences" xmlns="" />
  <!--
    ============================================================
                                        GetTargetPath

    This target returns an item containing the build product (i.e. EXE, DLL)
    that would be produced if we built this project, with some relevant
    metadata.
    ============================================================
    -->
  <Target Name="GetTargetPath" DependsOnTargets="$(GetTargetPathDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="" />
  <!--
    ============================================================
                                        GetTargetPathWithTargetPlatformMoniker

    This stand-alone target returns the name and version of the target platform for this project.

    NOTE: The ProjectReference protocol uses only GetTargetPath. Computing the item
    in this target allows projects to override GetTargetPath without having to reimplement
    the details of the metadata computation.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <GetTargetPathWithTargetPlatformMonikerDependsOn>$(GetTargetPathDependsOn)</GetTargetPathWithTargetPlatformMonikerDependsOn>
  </PropertyGroup>
  <!--NOTE: since an overridden GetTargetPath might not include a DependsOn
      for this target, it's safer to establish the dependency here with a
      BeforeTargets. -->
  <Target Name="GetTargetPathWithTargetPlatformMoniker" BeforeTargets="GetTargetPath" DependsOnTargets="$(GetTargetPathWithTargetPlatformMonikerDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="">
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion.TrimStart('vV'))</TargetFrameworkVersion>
        <ReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == 'true'">$(TargetRefPath)</ReferenceAssembly>
        <CopyUpToDateMarker>@(CopyUpToDateMarker)</CopyUpToDateMarker>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetNativeManifest

    Compute the manifest item for this project.

        [IN]
        $(_DeploymentApplicationManifestIdentity) - the manifest identity
        @(ApplicationManifest)         - the original application manifest item

        [OUT]
        @(ComputedApplicationManifest) - application manifest item with full hint path, if generated
    ============================================================
    -->
  <Target Name="GetNativeManifest" Returns="@(ComputedApplicationManifest)" xmlns="">
    <ItemGroup>
      <ComputedApplicationManifest Include="$(_DeploymentApplicationManifestIdentity)" Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe' and Exists('%(_ApplicationManifestFinal.FullPath)')">
        <HintPath>%(_ApplicationManifestFinal.FullPath)</HintPath>
      </ComputedApplicationManifest>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveNativeReferences

    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(_DeploymentNativePrerequisite)   - List of native assembly prerequisites contained in the manifest.
        @(ComClassReference)    - List of COM components contained in the manifest.
        @(COMReferenceFromNative) List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(_DeploymentLooseManifestFile)    - List of extra files that should be published.
    ============================================================
    -->
  <Target Name="ResolveNativeReferences" Condition="'@(NativeReference)'!=''" DependsOnTargets="ResolveProjectReferences" xmlns="">
    <ResolveNativeReference NativeReferences="@(NativeReference)" AdditionalSearchPaths="$(ReferencePath);$(OutDir)">
      <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile" />
      <Output TaskParameter="ContainedPrerequisiteAssemblies" ItemName="_DeploymentNativePrerequisite" />
      <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference" />
      <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReferenceFromNative" />
      <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference" />
      <Output TaskParameter="ContainedLooseEtcFiles" ItemName="_DeploymentLooseManifestFile" />
    </ResolveNativeReference>
  </Target>
  <!--
    ============================================================

                                        ResolveAssemblyReferences

    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(_ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to the Copy Local flag in IDE.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(_ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(_ReferenceSerializationAssemblyPaths) - Paths to XML serialization assemblies created by sgen.
        @(_ReferenceScatterPaths) - Paths to scatter files.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResolveAssemblyReferencesDependsOn>
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      PrepareForBuild;
      ResolveSDKReferences;
      ExpandSDKReferences;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveAssemblyReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)" xmlns="">
    <ItemGroup>
      <_ReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
      <_ReferenceInstalledAssemblySubsets Include="$(TargetFrameworkSubset)" />
    </ItemGroup>
    <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
    <PropertyGroup>
      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <!-- Make an App.Config item that exists when AutoUnify is false. -->
    <ItemGroup>
      <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Default in task is true -->
      <_FindDependencies Condition="'$(BuildingProject)' != 'true' and '$(_ResolveReferenceDependencies)' != 'true'">false</_FindDependencies>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == '' and '$(TraceDesignTime)' != 'true' and '$(BuildingProject)' == 'false'">true</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == ''">false</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Warning</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
      <ResolveAssemblyReferencesFindRelatedSatellites Condition="'$(ResolveAssemblyReferencesFindRelatedSatellites)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedSatellites>
      <ResolveAssemblyReferencesFindSerializationAssemblies Condition="'$(ResolveAssemblyReferencesFindSerializationAssemblies)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindSerializationAssemblies>
      <ResolveAssemblyReferencesFindRelatedFiles Condition="'$(ResolveAssemblyReferencesFindRelatedFiles)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedFiles>
      <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">false</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
    </PropertyGroup>
    <ItemGroup>
      <!-- Remove any references which we have added as explicit reference so that we do not get duplicates. We need to make sure we do not have duplicates
             because this confuses the IDE  when it tries to compare the list of references passed in to the list of resolved references. If it does not match then the
             ide will show one of the references as not resolved, this will not break the build but is a display issue -->
      <Reference Remove="$(AdditionalExplicitAssemblyReferences)" />
      <Reference Include="$(AdditionalExplicitAssemblyReferences)">
        <Implicit>true</Implicit>
      </Reference>
    </ItemGroup>
    <!--
      Normally, as an optimization, finding dependencies of references marked with ExternallyResolved=true metadata is skipped.
      However, skipping that step breaks binding redirect generation when there are conflicting versions within the externally
      resolved graph.
    -->
    <PropertyGroup Condition="'$(FindDependenciesOfExternallyResolvedReferences)' == ''">
      <FindDependenciesOfExternallyResolvedReferences>false</FindDependenciesOfExternallyResolvedReferences>
      <FindDependenciesOfExternallyResolvedReferences Condition="'$(AutoGenerateBindingRedirects)' == 'true'">true</FindDependenciesOfExternallyResolvedReferences>
    </PropertyGroup>
    <ResolveAssemblyReference Assemblies="@(Reference)" AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)" TargetFrameworkDirectories="@(_ReferenceInstalledAssemblyDirectory)" InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)" IgnoreDefaultInstalledAssemblyTables="$(IgnoreDefaultInstalledAssemblyTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" CandidateAssemblyFiles="@(Content);@(None)" SearchPaths="$(AssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)" AutoUnify="$(AutoUnifyAssemblyReferences)" SupportsBindingRedirectGeneration="$(GenerateBindingRedirectsOutputType)" IgnoreVersionForFrameworkReferences="$(IgnoreVersionForFrameworkReferences)" FindDependencies="$(_FindDependencies)" FindSatellites="$(ResolveAssemblyReferencesFindRelatedSatellites)" FindSerializationAssemblies="$(ResolveAssemblyReferencesFindSerializationAssemblies)" FindRelatedFiles="$(ResolveAssemblyReferencesFindRelatedFiles)" Silent="$(ResolveAssemblyReferencesSilent)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(ResolveAssemblyReferencesStateFile)" AssemblyInformationCachePaths="$(AssemblyInformationCachePaths)" AssemblyInformationCacheOutputPath="$(AssemblyInformationCacheOutputPath)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" LatestTargetFrameworkDirectories="@(LatestTargetFrameworkDirectories)" CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)" DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)" ResolvedSDKReferences="@(ResolvedSDKReference)" WarnOrErrorOnTargetArchitectureMismatch="$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)" IgnoreTargetFrameworkAttributeVersionMismatch="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)" FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)" ContinueOnError="$(ContinueOnError)" OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)" Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths" />
      <Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths" />
      <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths" />
      <Output TaskParameter="SerializationAssemblyFiles" ItemName="_ReferenceSerializationAssemblyPaths" />
      <Output TaskParameter="ScatterFiles" ItemName="_ReferenceScatterPaths" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime" />
      <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard" />
      <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================

                                        FindReferenceAssembliesForReferences

    Given the list of references, create a list of assemblies to pass to the compiler that
    includes reference assemblies rather than implementation assemblies where possible.

        [IN]
        @(ReferencePath) - List of assembly references as resolved paths with ReferenceAssembly metadata

        [OUT]
        @(ReferencePathWithRefAssemblies) - Paths to resolved reference (or implementation) assemblies.
    ============================================================
    -->
  <Target Name="FindReferenceAssembliesForReferences" DependsOnTargets="ResolveReferences" xmlns="">
    <ItemGroup>
      <!-- Reference assemblies are not produced in all cases, but it's easier to consume them
           if this metadatum is always populated. Ensure that it points to the implementation
           assembly unless already specified. -->
      <ReferencePath Condition="'%(ReferencePath.ReferenceAssembly)' == ''">
        <ReferenceAssembly>%(FullPath)</ReferenceAssembly>
      </ReferencePath>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath->'%(ReferenceAssembly)')" Condition="'$(CompileUsingReferenceAssemblies)' != 'false'">
        <OriginalPath Condition="'%(ReferencePath.Identity)' != '@(ReferencePath->'%(ReferenceAssembly)')'">%(ReferencePath.Identity)</OriginalPath>
      </ReferencePathWithRefAssemblies>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath)" Condition="'$(CompileUsingReferenceAssemblies)' == 'false'" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirects
    Inject the binding redirects into the app config file based on suggested redirects as output from
    ResolveAssemblyReferences.

        [IN]
        @(AppConfigWithTargetPath) - Path to the source app config file. This can be null if the project
                                     doesn't contain an app config file.
        $(TargetFileName) -          The file name of the build target.

        [OUT]
        @(OutputAppConfigFile) -     Path to the output app config file in the intermediate directory.

    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirects" Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)" Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="_GenerateSuggestedBindingRedirectsCache" xmlns="">
    <GenerateBindingRedirects AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)" SuggestedRedirects="@(SuggestedBindingRedirects)" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateBindingRedirectsIntermediateAppConfig)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirectsUpdateAppConfig
    Updates the project to use the generated app.config content.  This needs to run regardless of
    inputs/outputs so it is seperate from GenerateBindingRedirects.
    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirectsUpdateAppConfig" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'" xmlns="">
    <PropertyGroup>
      <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
      <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
    </PropertyGroup>
    <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="$(AppConfig)">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ===========================================================================================
                                        GetInstalledSDKs

    Gets the list of SDKs installed in the SDKDirectoryRoot and SDKRegistryRoot locations

    These paths are used by the ResolveSDKReference task and the ResolveAssemblyReference task.
    ===========================================================================================
  -->
  <PropertyGroup xmlns="">
    <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
    <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
    <!-- Manifest driven extension SDK locations -->
    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(WindowsKitsRoot)</SDKExtensionDirectoryRoot>
    <!-- UAP projects by default should support Windows 8.1 SDKs -->
    <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
    <TargetPlatformIdentifierWindows81 Condition="'$(TargetPlatformIdentifierWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">Windows</TargetPlatformIdentifierWindows81>
    <TargetPlatformVersionWindows81 Condition="'$(TargetPlatformVersionWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">8.1</TargetPlatformVersionWindows81>
    <!-- Desktop and phone SDKs often have the exact same identifiers, don't enable phone by default -->
    <SupportWindowsPhone81SDKs Condition="'$(SupportWindowsPhone81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">false</SupportWindowsPhone81SDKs>
    <TargetPlatformIdentifierWindowsPhone81 Condition="'$(TargetPlatformIdentifierWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">WindowsPhoneApp</TargetPlatformIdentifierWindowsPhone81>
    <TargetPlatformVersionWindowsPhone81 Condition="'$(TargetPlatformVersionWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">8.1</TargetPlatformVersionWindowsPhone81>
  </PropertyGroup>
  <Target Name="GetInstalledSDKLocations" Condition="'@(SDKReference)' != ''" DependsOnTargets="$(GetInstalledSDKLocationsDependsOn)" Returns="@(InstalledSDKLocations)" xmlns="">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <!-- Also lookup 8.1 SDKs if requested -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindows81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindows81)" Condition="'$(SupportWindows81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindows81)' != '' and '$(TargetPlatformVersionWindows81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindowsPhone81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindowsPhone81)" Condition="'$(SupportWindowsPhone81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindowsPhone81)' != '' and '$(TargetPlatformVersionWindowsPhone81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
  </Target>
  <!--
    ============================================================

                                        ResolveSDKReferences

    Given a list of SDKReference items and a list of resolved winmd files which may contain metadata as to which sdk they came from
    we need to find the sdk root folders on disk and populate a ResolvedSDKReference item which has the full path to the SDK ROOT
    and the sdk identity as a piece of metadata.

        [IN]
        @(SDKReference) - List of sdk references (the identity in the sdk manifest file).
        @(ReferencePath) -List of resolved assemblies, we are interested in the ones which have IsWinMDFile set to true.

        [OUT]
        @(ResolvedSDKReference) - Full path to the root of the SDK
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <ResolveSDKReferencesDependsOn>
      GetInstalledSDKLocations
    </ResolveSDKReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Debug'">Debug</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Release'">Retail</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == ''">Retail</TargetedSDKConfiguration>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">$(ProcessorArchitecture)</TargetedSDKArchitecture>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">Neutral</TargetedSDKArchitecture>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ShouldMarkCertainSDKReferencesAsRuntimeOnly Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == ''">true</ShouldMarkCertainSDKReferencesAsRuntimeOnly>
  </PropertyGroup>
  <ItemGroup Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == 'true'" xmlns="">
    <!-- Dependencies that are specified as runtime-only dependencies. Therefore the associated files are not used to build Appx package.  -->
    <!-- TODO: Do we need to do anything like this for the new SDK? -->
    <RuntimeReferenceOnlySDKDependencies Condition="'$(TargetPlatformVersion)' == '8.1'" Include="Microsoft.VCLibs, Version=11.0" />
  </ItemGroup>
  <Target Name="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" DependsOnTargets="$(ResolveSDKReferencesDependsOn)" xmlns="">
    <ResolveSDKReference SDKReferences="@(SDKReference)" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(SDKReference)'!=''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedSDKReference" />
    </ResolveSDKReference>
  </Target>
  <Target Name="ResolveSDKReferencesDesignTime" Returns="@(ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferences" xmlns="" />
  <!--
    ============================================================

                                        FindInvalidProjectReferences

    Find project to project references with target platform version higher than the one used by the current project and
    creates a list of invalid references to be unresolved. It issues a warning for each invalid reference.

        [IN]
        $(TargetPlatformVersion) - Project's target platform version
        @(_ProjectReferenceTargetPlatformMonikers) - List of monikers of all referenced projects gathered by the helper
                                                     target GetTargetPlatformMonikers.

        [OUT]
    @(InvalidProjectReferences) - List of invalid project references

    ============================================================
    -->
  <PropertyGroup xmlns="">
    <FindInvalidProjectReferencesDependsOn>
      GetReferenceTargetPlatformMonikers
    </FindInvalidProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="FindInvalidProjectReferences" Condition="'$(FindInvalidProjectReferences)' == 'true'" DependsOnTargets="$(FindInvalidProjectReferencesDependsOn)" xmlns="">
    <FindInvalidProjectReferences TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
      <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
    </FindInvalidProjectReferences>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(InvalidProjectReferences)" />
    </ItemGroup>
  </Target>
  <Target Name="GetReferenceTargetPlatformMonikers" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Targets="GetTargetPathWithTargetPlatformMoniker" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
    </MSBuild>
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(FindInvalidProjectReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="Build" Targets="GetTargetPathWithTargetPlatformMoniker" />
  </ItemGroup>
  <!--
    ============================================================

                       ExpandSDKReferences

        After we have resolved the sdk refrence we need to make sure that we automatically include the references which are part of the SDK (both winmd and dll)
        as part of the assemblies passed to the compiler.

        Project systems or project which do not want to reference all dlls or winmd files should override this target to do nothing.
   ============================================================
    -->
  <PropertyGroup xmlns="">
    <ExpandSDKReferencesDependsOn>
      ResolveSDKReferences
    </ExpandSDKReferencesDependsOn>
    <ExpandSDKAllowedReferenceExtensions Condition="'$(ExpandSDKAllowedReferenceExtensions)' == ''">
      .winmd;
      .dll
    </ExpandSDKAllowedReferenceExtensions>
  </PropertyGroup>
  <Target Name="ExpandSDKReferences" Returns="@(ReferencesFromSDK)" DependsOnTargets="$(ExpandSDKReferencesDependsOn)" xmlns="">
    <GetSDKReferenceFiles ResolvedSDKReferences="@(ResolvedSDKReference)" ReferenceExtensions="$(ExpandSDKAllowedReferenceExtensions)" TargetSDKIdentifier="$(SDKIdentifier)" TargetSDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" LogRedistFilesList="$(GetSDKReferenceFilesLogRedistFilesList)" LogRedistConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogRedistConflictsWithinSDKAsWarning)" LogRedistConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogRedistConflictsBetweenSDKsAsWarning)" LogReferencesList="$(GetSDKReferenceFilesLogReferencesList)" LogReferenceConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsWithinSDKAsWarning)" LogReferenceConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsBetweenSDKsAsWarning)" CacheFileFolderPath="$(GetSDKReferenceFilesCacheFolder)" LogCacheFileExceptions="$(GetSDKReferenceFilesLogCacheFileExceptions)" Condition="'@(ResolvedSDKReference)'!=''">
      <Output TaskParameter="References" ItemName="ReferencePath" />
      <Output TaskParameter="References" ItemName="ReferencesFromSDK" />
      <Output TaskParameter="References" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="RedistFiles" ItemName="ResolvedRedistFiles" />
    </GetSDKReferenceFiles>
  </Target>
  <!--
    ============================================================

                                        ExportWindowsMDFile

    When a project is generating a a winmd file through c# or vb, ect the compiler will create a WinMDModule file. This file needs to be run
    through the winmdexp tool in order to generate the resulting WinMD file.

    ===========================================================
    -->
  <Target Name="ExportWindowsMDFile" DependsOnTargets="Compile" Condition="'$(ExportWinMDFile)' == 'true'" Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePathWithRefAssemblies);$(MSBuildAllProjects)" Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)" xmlns="">
    <PropertyGroup>
      <!-- Will be copied by the "copy WinMD artifacts" step instead -->
      <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory>false</CopyDocumentationFileToOutputDirectory>
      <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</WinMdExpToolPath>
      <WinMdExpUTF8Ouput Condition="'$(WinMdExpUTF8Ouput)' == ''">true</WinMdExpUTF8Ouput>
    </PropertyGroup>
    <WinMDExp WinMDModule="@(IntermediateAssembly)" References="@(ReferencePathWithRefAssemblies)" DisabledWarnings="$(WinMdExpNoWarn)" InputDocumentationFile="@(DocFileItem)" OutputDocumentationFile="$(WinMDOutputDocumentationFile)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" InputPDBFile="@(_DebugSymbolsIntermediatePath)" OutputPDBFile="$(WinMDExpOutputPdb)" OutputWindowsMetadataFile="$(_IntermediateWindowsMetadataPath)" EnvironmentVariables="$(WinMDExpEnvironment)" UTF8Output="$(WinMdExpUTF8Ouput)" SdkToolsPath="$(WinMdExpToolPath)" AssemblyUnificationPolicy="$(WinMDExpAssemblyUnificationPolicy)">
      <Output TaskParameter="OutputWindowsMetadataFile" ItemName="FileWrites" />
    </WinMDExp>
    <ItemGroup>
      <WinMDExpArtifacts Include="$(_IntermediateWindowsMetadataPath)" />
      <WinMDExpArtifacts Include="$(WinMDOutputDocumentationFile)" />
      <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)" />
      <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveAssemblyReferencesDesignTime" Returns="@(_ReferencesFromRAR)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences" xmlns="">
    <!-- We need to do this here because we only want references which have been passed into rar but are not project to project references. -->
    <ItemGroup>
      <_ReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))" />
    </ItemGroup>
  </Target>
  <PropertyGroup xmlns="">
    <ProjectDesignTimeAssemblyResolutionSearchPaths Condition=" '$(ProjectDesignTimeAssemblyResolutionSearchPaths)' == '' ">
      {CandidateAssemblyFiles};
      $(ReferencePath);
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
      {RawFileName};
      $(TargetDir)
    </ProjectDesignTimeAssemblyResolutionSearchPaths>
  </PropertyGroup>
  <!--
    ==============================================================

                                       DesignTimeResolveAssemblyReferences

    Given the list of assemblies, resolve their reference paths.
    This target is called by Visual Studio at run time in order to filter references
    according to the targeted framework.

        [IN]
        @(DesignTimeReference) - List of assembly references as simple/fusion names.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.

    ==============================================================
    -->
  <PropertyGroup xmlns="">
    <DesignTimeResolveAssemblyReferencesDependsOn>
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      ResolveReferences
    </DesignTimeResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeResolveAssemblyReferences" Condition="'$(DesignTimeReference)'!=''" DependsOnTargets="$(DesignTimeResolveAssemblyReferencesDependsOn)" xmlns="">
    <ItemGroup>
      <_DesignTimeReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
    </ItemGroup>
    <PropertyGroup>
      <DesignTimeResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true'">$(IntermediateOutputPath)$(MSBuildProjectFile)DesignTimeResolveAssemblyReferences.cache</DesignTimeResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">
        {CandidateAssemblyFiles};
        $(ReferencePath);
        {HintPathFromItem};
        {TargetFrameworkDirectory};
        {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
        {RawFileName};
        $(OutDir)
      </DesignTimeAssemblySearchPaths>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeFindDependencies Condition=" '$(DesignTimeFindDependencies)' == '' ">false</DesignTimeFindDependencies>
      <DesignTimeIgnoreVersionForFrameworkReferences Condition=" '$(DesignTimeIgnoreVersionForFrameworkReferences)' == '' ">false</DesignTimeIgnoreVersionForFrameworkReferences>
      <DesignTimeFindSatellites Condition=" '$(DesignTimeFindSatellites)' == '' ">false</DesignTimeFindSatellites>
      <DesignTimeFindSerializationAssemblies Condition=" '$(DesignTimeFindSerializationAssemblies)' == '' ">false</DesignTimeFindSerializationAssemblies>
      <DesignTimeFindRelatedFiles Condition=" '$(DesignTimeFindRelatedFiles)' == '' ">false</DesignTimeFindRelatedFiles>
      <DesignTimeSilentResolution Condition=" '$(DesignTimeSilentResolution)' == '' and '$(TraceDesignTime)' != 'true'">true</DesignTimeSilentResolution>
      <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">false</DesignTimeAutoUnify>
    </PropertyGroup>
    <ItemGroup>
      <_DesignTimeReferenceAssemblies Include="$(DesignTimeReference)" />
    </ItemGroup>
    <ItemGroup>
      <_RARResolvedReferencePath Include="@(ReferencePath)" />
      <ReferencePath Remove="@(ReferencePath)" />
    </ItemGroup>
    <ResolveAssemblyReference Assemblies="@(_DesignTimeReferenceAssemblies)" TargetFrameworkDirectories="@(_DesignTimeReferenceInstalledAssemblyDirectory)" SearchPaths="$(DesignTimeAssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" CandidateAssemblyFiles="@(Content);@(None);@(_RARResolvedReferencePath)" FindDependencies="$(DesignTimeFindDependencies)" AutoUnify="$(DesignTimeAutoUnify)" IgnoreVersionForFrameworkReferences="$(DesignTimeIgnoreVersionForFrameworkReferences)" FindSatellites="$(DesignTimeFindSatellites)" FindSerializationAssemblies="$(DesignTimeFindSerializationAssemblies)" FindRelatedFiles="$(DesignTimeFindRelatedFiles)" Silent="$(DesignTimeSilentResolution)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(DesignTimeResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" ResolvedSDKReferences="@(ResolvedSDKReference)" IgnoreTargetFrameworkAttributeVersionMismatch="$(DesignTimeIgnoreTargetFrameworkAttributeVersionMismatch)">
      <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================
                                        ResolveComReferences

    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(InteropOutputPath) - The output directory in which to generate wrapper assemblies
                               When $(InteropOutputPath) is not set, then it defaults to $(IntermediateOutputPath).

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ComReferenceExecuteAsTool Condition="'$(ComReferenceExecuteAsTool)'==''">false</ComReferenceExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResolveComReferences" Condition="'@(COMReference)'!='' or '@(COMFileReference)'!=''" Returns="@(ReferencePath)" DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences" xmlns="">
    <PropertyGroup Condition=" '$(InteropOutputPath)' == '' ">
      <InteropOutputPath>$(IntermediateOutputPath)</InteropOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(InteropOutputPath)" />
    <!--
        Note: This task should not be batched, since it relies on having all the COM references fed into it at once.
        -->
    <PropertyGroup>
      <ResolveComReferenceMSBuildArchitecture Condition="'$(ResolveComReferenceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</ResolveComReferenceMSBuildArchitecture>
      <ResolveComReferenceToolPath Condition="'$(ResolveComReferenceToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResolveComReferenceToolPath>
      <ResolveComReferenceSilent Condition="'$(ResolveComReferenceSilent)' == ''">false</ResolveComReferenceSilent>
    </PropertyGroup>
    <ResolveComReference TypeLibNames="@(COMReference)" TypeLibFiles="@(COMFileReference)" ResolvedAssemblyReferences="@(ReferencePath)" WrapperOutputDirectory="$(InteropOutputPath)" IncludeVersionInInteropName="$(IncludeVersionInInteropName)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" StateFile="@(_ResolveComReferenceCache)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetProcessorArchitecture="$(ProcessorArchitecture)" NoClassMembers="$(ComReferenceNoClassMembers)" Silent="$(ResolveComReferenceSilent)" EnvironmentVariables="$(ResolveComReferenceEnvironment)" SdkToolsPath="$(ResolveComReferenceToolPath)" ExecuteAsTool="$(ComReferenceExecuteAsTool)" MSBuildArchitecture="$(ResolveComReferenceMSBuildArchitecture)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="ComReferenceWrappers" />
      <Output TaskParameter="ResolvedFiles" ItemName="FileWrites" />
      <!-- This output list only includes items with Isolated attribute set to True.  It's done by the task itself. -->
      <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules" />
    </ResolveComReference>
    <ItemGroup>
      <FileWrites Include="@(_ResolveComReferenceCache)" />
      <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GetAssembliesMetadata

    Resolve Assembly attributes for assemblies
    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,
    but this target handles all the assembly references from ResolveAssemblyReferences
    This target is needed by the Visual Studio legacy project system during design time build only

        [IN]
        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.

        [OUT]
        @(AssembliesMetadata) - Resolved assemblies attributes.
    ============================================================
    -->
  <Target Name="_GetAssembliesMetadata" Condition="'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' " Returns="@(_AssembliesMetadata)" DependsOnTargets="ResolveComReferences" xmlns="">
    <GetAssembliesMetadata AssemblyPaths="@(ReferencePath)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="AssembliesMetadata" ItemName="_AssembliesMetadata" />
    </GetAssembliesMetadata>
  </Target>
  <Target Name="ResolveComReferencesDesignTime" Returns="@(ComReferenceWrappers)" DependsOnTargets="ResolveComReferences" xmlns="" />
  <!--
    ============================================================
                                      ResolveFrameworkReferences

    Overrridden by Microsoft.NET.Sdk to return
    ResolvedFrameworkReference items in order to populate the
    Frameworks node of the Solution Explorer in the IDE.
  -->
  <Target Name="ResolveFrameworkReferences" xmlns="" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareResources Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareResources

    Prepare resources for the Compile step.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareResourcesDependsOn>
      $(PrepareResourcesDependsOn);
      PrepareResourceNames;
      ResGen;
      CompileLicxFiles
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResources" DependsOnTargets="$(PrepareResourcesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        PrepareResourceNames

    Prepare the names of resource files.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareResourceNamesDependsOn>
      AssignTargetPaths;
      SplitResourcesByCulture;
      CreateManifestResourceNames;
      CreateCustomManifestResourceNames
    </PrepareResourceNamesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResourceNames" DependsOnTargets="$(PrepareResourceNamesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        AssignTargetPaths

    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <AssignTargetPathsDependsOn />
  </PropertyGroup>
  <Target Name="AssignTargetPaths" DependsOnTargets="$(AssignTargetPathsDependsOn)" xmlns="">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- AssignTargetPath generates TargetPath metadata that is consumed by CreateManifestResourceNames target for manifest name generation -->
    <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
      <EmbeddedResource Remove="@(_Temporary)" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_NoneWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(BaseApplicationManifest)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)" Condition="'@(_DeploymentBaseManifestWithTargetPath)'=='' and '%(None.Extension)'=='.manifest'">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
  </Target>
  <!--
    ============================================================
                                        GetItemTargetPaths

    This target returns all items that have TargetPath metadata assigned by the AssignTargetPaths target.
    ============================================================
    -->
  <Target Name="GetItemTargetPaths" DependsOnTargets="AssignTargetPaths" Returns="&#xD;&#xA;      @(EmbeddedResource);&#xD;&#xA;      @(ContentWithTargetPath);&#xD;&#xA;      @(_NoneWithTargetPath);&#xD;&#xA;      @(_DeploymentBaseManifestWithTargetPath);&#xD;&#xA;      " xmlns="" />
  <!--
    ============================================================
                                        SplitResourcesByCulture

    Split EmbeddedResource items into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized. Also adds Type and Culture
    metadata. Type indicates whether the resource is "Resx" or "Non-Resx".

        [IN]/[OUT]
        @(EmbeddedResource) - The raw list of resources.

        [OUT]
        @(_LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
    ============================================================
    -->
  <Target Name="SplitResourcesByCulture" DependsOnTargets="AssignTargetPaths" xmlns="">
    <PropertyGroup>
      <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'@(ResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9000;ResxWithNoCulture" />
    <MSBuildInternalMessage Condition="'@(ResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9001;ResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9002;NonResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9003;NonResxWithNoCulture" />
    <ItemGroup>
      <_LicxFile Include="@(EmbeddedResource)" Condition="'%(Extension)'=='.licx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <EmbeddedResource Include="@(ResxWithNoCulture);@(ResxWithCulture)">
        <Type>Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(NonResxWithCulture);@(NonResxWithNoCulture)">
        <Type>Non-Resx</Type>
      </EmbeddedResource>
    </ItemGroup>
    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'" RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)">
      <!-- Create the list of culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture" />
      <!-- Create the list of non-culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_MixedResourceWithNoCulture" />
    </AssignCulture>
    <ItemGroup>
      <!-- Remove EmbeddedResource items that we have processed already
                 i.e. either Licx, or resources that don't have culture info -->
      <EmbeddedResource Remove="@(_MixedResourceWithCulture)" />
      <EmbeddedResource Remove="@(_MixedResourceWithNoCulture)" />
      <EmbeddedResource Remove="@(_LicxFile)" />
      <!-- Add back everything except Licx, so that we have culture info -->
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'=='.resx' or '%(Extension)'=='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'!='.resx' and '%(Extension)'!='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Non-Resx</Type>
      </EmbeddedResource>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ResxWithNoCulture Remove="@(ResxWithNoCulture)" />
      <NonResxWithNoCulture Remove="@(NonResxWithNoCulture)" />
      <ResxWithCulture Remove="@(ResxWithCulture)" />
      <NonResxWithCulture Remove="@(NonResxWithCulture)" />
      <ResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <ResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <!-- Clean up temporary lists -->
      <_MixedResourceWithNoCulture Remove="@(_MixedResourceWithNoCulture)" />
      <_MixedResourceWithCulture Remove="@(_MixedResourceWithCulture)" />
    </ItemGroup>
  </Target>
  <!--
    =======================================================================
                                        CreateCustomManifestResourceNames

    Allows custom manifest resource name generation tasks to plug
    into the build process
    =======================================================================
    -->
  <PropertyGroup xmlns="">
    <CreateCustomManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateCustomManifestResourceNames" DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        ResGen

    Run GenerateResource on the given resx files.

    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResGenDependsOn>ResolveAssemblyReferences;SplitResourcesByCulture;BeforeResGen;CoreResGen;AfterResGen</ResGenDependsOn>
    <CoreResGenDependsOn>FindReferenceAssembliesForReferences</CoreResGenDependsOn>
    <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResGen" DependsOnTargets="$(ResGenDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeResGen

    Redefine this target in your project in order to run tasks just before Resgen.
    ============================================================
    -->
  <Target Name="BeforeResGen" xmlns="" />
  <!--
    ============================================================
                                        AfterResGen

    Redefine this target in your project in order to run tasks just after Resgen.
    ============================================================
    -->
  <Target Name="AfterResGen" xmlns="" />
  <!--
    ============================================================
                                        CoreResGen
    ============================================================
    -->
  <Target Name="CoreResGen" DependsOnTargets="$(CoreResGenDependsOn)" xmlns="">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <PropertyGroup>
      <GenerateResourceMSBuildArchitecture Condition="'$(GenerateResourceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</GenerateResourceMSBuildArchitecture>
      <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(GenerateResourceMSBuildArchitecture)' != ''">
      <!-- In the general case, we want to fail to run the task if the task host it's requesting doesn't exist, because we'd rather let the
           user know there's something wrong than just silently generate something that's probably not quite right. However, in a few
           circumstances, there are tasks that are already aware of runtime / bitness concerns, in which case even if we go ahead and run
           the more recent version of the task, it should be able to generate something correct.  GenerateResource is one such task, so
           we check for the existence of the targeted task host so that we can use it preferentially, but if it can't be found, we'll fall
           back to the current task since it's still mostly correct.

           In particular, we need to do this because otherwise people with Dev10 on a machine that they upgrade to Win8 will be broken:
           they'll have ResGen from the 7.0A SDK installed, so launching ResGen will still work, but the CLR2 task host is only installed by
           the 8.0A SDK, which they won't have installed, and thus without this fallback mechanism, their projects targeting v3.5 will
           suddenly start failing to build.-->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(GenerateResourceMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</GenerateResourceMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == ''">CurrentRuntime</GenerateResourceMSBuildRuntime>
    </PropertyGroup>
    <!-- 4.0 task has some new parameters that we want to make use of if we're targeting 4.0 -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePathWithRefAssemblies)" UsePreserializedResources="$(GenerateResourceUsePreserializedResources)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' != 'CLR2'" SdkToolsPath="$(ResgenToolPath)" ExecuteAsTool="$(ResGenExecuteAsTool)" EnvironmentVariables="$(ResGenEnvironment)" WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <!-- But we can't use those parameters if we're targeting 3.5, since we're using the 3.5 task -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' == 'CLR2'">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temporary)" />
      <!-- Add back the Sources list (with OutputResource metadata) that we output from GenerateResource into EmbeddedResource -->
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithNoCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithNoCulture>
      <ManifestNonResxWithNoCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithNoCultureOnDisk>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithCulture>
      <ManifestNonResxWithCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithCultureOnDisk>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        CompileLicxFiles

    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(_LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CompileLicxFilesDependsOn />
  </PropertyGroup>
  <Target Name="CompileLicxFiles" Condition="'@(_LicxFile)'!=''" DependsOnTargets="$(CompileLicxFilesDependsOn)" Inputs="$(MSBuildAllProjects);@(_LicxFile);@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses" xmlns="">
    <PropertyGroup>
      <LCMSBuildArchitecture Condition="'$(LCMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</LCMSBuildArchitecture>
    </PropertyGroup>
    <LC Sources="@(_LicxFile)" LicenseTarget="$(TargetFileName)" OutputDirectory="$(IntermediateOutputPath)" OutputLicense="$(IntermediateOutputPath)$(TargetFileName).licenses" ReferencedAssemblies="@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" NoLogo="$(NoLogo)" ToolPath="$(LCToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(LCEnvironment)" MSBuildArchitecture="$(LCMSBuildArchitecture)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile" />
      <Output TaskParameter="OutputLicense" ItemName="FileWrites" />
    </LC>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveKeySource Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        ResolveKeySource

    Resolve the strong name key used to sign the assembly as well as the certificate used to
    sign the ClickOnce manifests.

        [IN]
        $(AssemblyOriginatorKeyFile)     - The file used to sign the assembly (.snk or .pfx)
        $(ManifestCertificateThumbprint) - The thumbprint used to locate the certificate in the
                                           user's certificate store.
        $(ManifestKeyFile)               - The key file that contains the certificate in case the
                                           certificate is not in the user's store.

        [OUT]
        $(ResolvedAssemblyKeyFile)        - Key used to sign the assembly
        $(_DeploymentResolvedManifestCertificateThumbprint) - Certificate used to sign the manifests
    ============================================================
    -->
  <Target Name="ResolveKeySource" Condition="$(SignManifests) == 'true' or $(SignAssembly) == 'true'" xmlns="">
    <ResolveKeySource KeyFile="$(AssemblyOriginatorKeyFile)" CertificateThumbprint="$(ManifestCertificateThumbprint)" CertificateFile="$(ManifestKeyFile)" SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)" ShowImportDialogDespitePreviousFailures="$(BuildingProject)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ResolvedKeyFile" PropertyName="KeyOriginatorFile" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedKeyContainer" PropertyName="KeyContainerName" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedThumbprint" PropertyName="_DeploymentResolvedManifestCertificateThumbprint" Condition=" '$(SignManifests)' == 'true' " />
    </ResolveKeySource>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Compile Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Compile
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CompileDependsOn>
      ResolveReferences;
      ResolveKeySource;
      SetWin32ManifestProperties;
      _SetPreferNativeArm64Win32ManifestProperties;
      FindReferenceAssembliesForReferences;
      _GenerateCompileInputs;
      BeforeCompile;
      _TimeStampBeforeCompile;
      _GenerateCompileDependencyCache;
      CoreCompile;
      _TimeStampAfterCompile;
      AfterCompile;
    </CompileDependsOn>
  </PropertyGroup>
  <Target Name="Compile" DependsOnTargets="$(CompileDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _GenerateCompileInputs

    Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
    ============================================================
    -->
  <Target Name="_GenerateCompileInputs" xmlns="">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9004;ManifestResourceWithNoCulture;false;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithNoCultureOnDisk)'!='' and '%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9005;ManifestNonResxWithNoCultureOnDisk;false;Non-Resx" />
    <ItemGroup>
      <!-- _CoreCompileResourceInputs is the list of TLDA inputs that should trigger CoreCompile, and are listed as inputs to that target -->
      <_CoreCompileResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_CoreCompileResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Non-Resx' " />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_CoreCompileResourceInputs Include="@(ManifestResourceWithNoCulture)" Condition="'%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
      <_CoreCompileResourceInputs Include="@(ManifestNonResxWithNoCultureOnDisk)" Condition="'%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateTargetFrameworkMonikerAttribute

    Emit the target framework moniker attribute as  a code fragment into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''" xmlns="">
    <!-- Do not clean if we are going to default the path to the temp directory -->
    <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <GenerateTargetFrameworkAttribute Condition="'$(GenerateTargetFrameworkAttribute)' == '' and '$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">true</GenerateTargetFrameworkAttribute>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == 'true'" xmlns="">
    <Clean Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
  </ItemGroup>
  <Target Name="GenerateTargetFrameworkMonikerAttribute" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets" Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'@(Compile)' != '' and '$(GenerateTargetFrameworkAttribute)' == 'true'" xmlns="">
    <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
             and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
    <WriteLinesToFile File="$(TargetFrameworkMonikerAssemblyAttributesPath)" Lines="$(TargetFrameworkMonikerAssemblyAttributeText)" Overwrite="true" ContinueOnError="true" Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''" />
    <ItemGroup Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''">
      <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
      <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateAdditionalSources

    Emit any specified code fragments into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(AssemblyAttributesPath)' != ''" xmlns="">
    <GenerateAdditionalSources Condition="'$(GenerateAdditionalSources)' == ''">true</GenerateAdditionalSources>
  </PropertyGroup>
  <ItemGroup Condition="'$(AssemblyAttributesPath)' != ''" xmlns="">
    <Clean Include="$(AssemblyAttributesPath)" Condition="'$(AssemblyAttributesFileClean)' != 'false'" />
  </ItemGroup>
  <Target Name="GenerateAdditionalSources" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildAllProjects)" Outputs="$(AssemblyAttributesPath)" Condition="'@(AssemblyAttributes)' != '' and '$(GenerateAdditionalSources)' == 'true'" xmlns="">
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttributes)" OutputFile="$(AssemblyAttributesPath)" Language="$(Language)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ============================================================
                                        BeforeCompile

    Redefine this target in your project in order to run tasks just before Compile.
    ============================================================
    -->
  <Target Name="BeforeCompile" xmlns="" />
  <!--
    ============================================================
                                        AfterCompile

    Redefine this target in your project in order to run tasks just after Compile.
    ============================================================
    -->
  <Target Name="AfterCompile" xmlns="" />
  <!--
    ============================================================
                                        _TimeStampBeforeCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampBeforeCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')" xmlns="">
    <PropertyGroup>
      <_AssemblyTimestampBeforeCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampBeforeCompile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateSuggestedBindingRedirectsCache
    Generate a file used to track whether suggested binding redirects changed between builds.
    @(SuggestedBindingRedirects) never contains a file on disk, so create a file
    that contains a hash of the items to prevent `GenerateBindingRedirects`
    from running every build.

    See https://github.com/dotnet/msbuild/issues/5943 for details.
    ============================================================
    -->
  <Target Name="_GenerateSuggestedBindingRedirectsCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences" xmlns="">
    <PropertyGroup>
      <SuggestedBindingRedirectsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectFile).SuggestedBindingRedirects.cache</SuggestedBindingRedirectsCacheFile>
    </PropertyGroup>
    <Hash ItemsToHash="@(SuggestedBindingRedirects)">
      <Output TaskParameter="HashResult" PropertyName="SuggestedBindingRedirectsHash" />
    </Hash>
    <WriteLinesToFile Lines="$(SuggestedBindingRedirectsHash)" File="$(SuggestedBindingRedirectsCacheFile)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(SuggestedBindingRedirectsCacheFile)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateCompileDependencyCache

    Generate a file used to track compiler dependencies between incremental build
    executions. This handles cases where items are added or removed from a glob (e.g.
    <Compile Include="**\*.cs" />) and can't otherwise be detected with timestamp
    comparisons. The file contains a hash of compiler inputs that are known to
    contribute to incremental build inconsistencies.
    ============================================================
    -->
  <Target Name="_GenerateCompileDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences" xmlns="">
    <ItemGroup>
      <CustomAdditionalCompileInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
      <CoreCompileCache Include="@(Compile)" />
      <CoreCompileCache Include="@(ReferencePath)" />
      <CoreCompileCache Include="$(DefineConstants)" />
      <CoreCompileCache Include="$(LangVersion)" />
      <CoreCompileCache Include="$(Deterministic)" />
      <CoreCompileCache Include="$(PathMap)" />
    </ItemGroup>
    <Hash ItemsToHash="@(CoreCompileCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CoreCompileCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CoreCompileDependencyHash" />
    </Hash>
    <WriteLinesToFile Lines="$(CoreCompileDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _TimeStampAfterCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampAfterCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')" xmlns="">
    <PropertyGroup>
      <_AssemblyTimestampAfterCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampAfterCompile>
    </PropertyGroup>
  </Target>
  <!--
    ================================================================
                                        _ComputeNonExistentFileProperty

    There are certain situations in which we want to always run the CoreCompile target (and
    thus the Csc task), even if the timestamps of the outputs appear to be up-to-date on disk.
    If we're inside the IDE during design-time, then the Csc/Vbc/Vjc task is simply being used to
    initialize the host compiler, so we always want to run it.  Also, if we're inside the IDE, and
    the host compiler is responsible for doing the compilation during an actual build, we want to let
    the host compiler determine whether the output is up-to-date, because there may be source files
    in the IDE's in-memory buffers that we don't know about.

    So, we always run the CoreCompile target if we're in the IDE, and either we're in design-time or
    we're delegating to the host compiler for the actual build.

    We compare against BuildOutOfProcess != true because we cannot assume that the build process will
    have set BuildOutOfProcess to true or false. Therefore the default behavior should be to do the
    legacy behavior seen before BuildingOutOfProcess was introduced if the property is not set.
    ================================================================
    -->
  <Target Name="_ComputeNonExistentFileProperty" Condition="('$(BuildingInsideVisualStudio)' == 'true') and ('$(BuildingOutOfProcess)' != 'true') and (('$(BuildingProject)' == 'false') or ('$(UseHostCompilerIfAvailable)' == 'true'))" xmlns="">
    <PropertyGroup>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateSerializationAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <_SGenDllName>$(TargetName).XmlSerializers.dll</_SGenDllName>
    <_SGenDllCreated>false</_SGenDllCreated>
    <_SGenGenerateSerializationAssembliesConfig>$(GenerateSerializationAssemblies)</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(GenerateSerializationAssemblies)' == ''">Auto</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(ConfigurationName)'=='Debug' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto'">Off</_SGenGenerateSerializationAssembliesConfig>
    <SGenUseProxyTypes Condition="'$(SGenUseProxyTypes)' == ''">true</SGenUseProxyTypes>
    <SGenUseKeep Condition="'$(SGenUseKeep)'==''">false</SGenUseKeep>
    <SGenShouldGenerateSerializer Condition="'$(SGenShouldGenerateSerializer)' == ''">true</SGenShouldGenerateSerializer>
  </PropertyGroup>
  <!--
    ============================================================
                                        GenerateSerializationAssemblies

    Run GenerateSerializationAssemblies on the assembly produced by this build.

        [IN]
        @(BuildAssemblyName) - The assembly generated by this build.
        @(BuildAssemblyPath) - The path where the assembly resides.
        @(ReferencePath) - The list of references used by this assembly.

        [OUT]
        @(SerializationAssembly) - The path to the serialization assembly.  Maybe we'll just append to an existing list.
    ============================================================
    -->
  <Target Name="GenerateSerializationAssemblies" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" DependsOnTargets="AssignTargetPaths;Compile;ResolveKeySource" Inputs="$(MSBuildAllProjects);@(IntermediateAssembly)" Outputs="$(IntermediateOutputPath)$(_SGenDllName)" xmlns="">
    <PropertyGroup>
      <SGenMSBuildArchitecture Condition="'$(SGenMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</SGenMSBuildArchitecture>
    </PropertyGroup>
    <SGen BuildAssemblyName="$(TargetFileName)" BuildAssemblyPath="$(IntermediateOutputPath)" References="@(ReferencePath)" ShouldGenerateSerializer="$(SGenShouldGenerateSerializer)" UseProxyTypes="$(SGenUseProxyTypes)" UseKeep="$(SGenUseKeep)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" ToolPath="$(SGenToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(SGenEnvironment)" MSBuildArchitecture="$(SGenMSBuildArchitecture)" SerializationAssembly="$(IntermediateOutputPath)$(_SGenDllName)" Platform="$(SGenPlatformTarget)" Types="$(SGenSerializationTypes)">
      <Output TaskParameter="SerializationAssembly" ItemName="SerializationAssembly" />
    </SGen>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                CreateSatelliteAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CreateSatelliteAssemblies

    Create one satellite assembly for every unique culture in the resources.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      _GenerateSatelliteAssemblyInputs;
      ComputeIntermediateSatelliteAssemblies;
      GenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="CreateSatelliteAssemblies" DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _GenerateSatelliteAssemblyInputs

    Create the _SatelliteAssemblyResourceInputs list of inputs to the CreateSatelliteAssemblies target.
    ============================================================
    -->
  <Target Name="_GenerateSatelliteAssemblyInputs" xmlns="">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithCulture)'!='' and '%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9006;ManifestResourceWithCulture;true;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithCultureOnDisk)'!='' and '%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9007;ManifestNonResxWithCultureOnDisk;true;Non-Resx" />
    <ItemGroup>
      <!-- _SatelliteAssemblyResourceInputs is the list of TLDA inputs that should trigger CreateSatelliteAssemblies, so listed as inputs to that target -->
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_SatelliteAssemblyResourceInputs Include="@(ManifestResourceWithCulture)" Condition="'%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
      <_SatelliteAssemblyResourceInputs Include="@(ManifestNonResxWithCultureOnDisk)" Condition="'%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    Actually run al.exe to create the satellite assemblies.
    ============================================================
    -->
  <Target Name="GenerateSatelliteAssemblies" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != '' and '$(GenerateSatelliteAssembliesForCore)' != 'true'" xmlns="">
    <PropertyGroup>
      <_ALExeToolPath Condition="'$(_ALExeToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</_ALExeToolPath>
    </PropertyGroup>
    <MakeDir Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
    <AL AlgorithmId="$(Satellite_AlgorithmId)" BaseAddress="$(Satellite_BaseAddress)" CompanyName="$(Satellite_CompanyName)" Configuration="$(Satellite_Configuration)" Copyright="$(Satellite_Copyright)" Culture="%(Culture)" DelaySign="$(DelaySign)" Description="$(Satellite_Description)" EmbedResources="@(_SatelliteAssemblyResourceInputs)" EnvironmentVariables="$(AlEnvironment)" EvidenceFile="$(Satellite_EvidenceFile)" FileVersion="$(Satellite_FileVersion)" Flags="$(Satellite_Flags)" GenerateFullPaths="$(Satellite_GenerateFullPaths)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LinkResources="@(Satellite_LinkResource)" MainEntryPoint="$(Satellite_MainEntryPoint)" OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Platform="$(PlatformTarget)" ProductName="$(Satellite_ProductName)" ProductVersion="$(Satellite_ProductVersion)" ResponseFiles="@(AlResponseFile)" SourceModules="@(Satellite_SourceModule)" TargetType="$(Satellite_TargetType)" TemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Title="$(Satellite_Title)" ToolPath="$(AlToolPath)" ToolExe="$(AlToolExe)" SdkToolsPath="$(_ALExeToolPath)" Trademark="$(Satellite_Trademark)" Version="$(Satellite_Version)" Win32Icon="$(Satellite_Win32Icon)" Win32Resource="$(Satellite_Win32Resource)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </AL>
  </Target>
  <!--
    ============================================================
                                        ComputeIntermediateSatelliteAssemblies

    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ComputeIntermediateSatelliteAssembliesDependsOn>
      CreateManifestResourceNames
    </ComputeIntermediateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="ComputeIntermediateSatelliteAssemblies" Condition="@(EmbeddedResource->'%(WithCulture)') != ''" DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)" xmlns="">
    <ItemGroup>
      <IntermediateSatelliteAssembliesWithTargetPath Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.Culture)' != ''">
        <Culture>%(EmbeddedResource.Culture)</Culture>
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
      </IntermediateSatelliteAssembliesWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                SetWin32ManifestProperties Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <EmbeddedWin32Manifest>$(Win32Manifest)</EmbeddedWin32Manifest>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetWin32ManifestProperties

    Set Win32Manifest and EmbeddedManifest properties to be used later in the build.
    ============================================================
    -->
  <Target Name="SetWin32ManifestProperties" Condition="'$(Win32Manifest)'==''" DependsOnTargets="ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties" xmlns="" />
  <Target Name="_SetExternalWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''" xmlns="">
    <PropertyGroup>
      <!-- set _DeploymentBaseManifest property to the value of $(ApplicationManifest) if the property is set,
                 but use _DeploymentBaseManifestWithTargetPath item-group if the property is not set to support backwards
                 compat with earlier MSBuild versions when manifest files were determined by the item-group. If the newer
                 property is set though, prefer that one be used to specify the manifest. -->
      <_DeploymentBaseManifest>$(ApplicationManifest)</_DeploymentBaseManifest>
      <_DeploymentBaseManifest Condition="'$(_DeploymentBaseManifest)'==''">@(_DeploymentBaseManifestWithTargetPath)</_DeploymentBaseManifest>
      <!-- when using external manifests, always set the NoWin32Manifest property to
                 true if there is no value set in the incoming project file so the
                 compilers that support manifest embedding know not to add
                 a manifest to their built assemblies -->
      <NoWin32Manifest Condition="'$(NoWin32Manifest)'==''">true</NoWin32Manifest>
    </PropertyGroup>
  </Target>
  <Target Name="_SetEmbeddedWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'!='true' and '@(NativeReference)'=='' and '@(ResolvedIsolatedComModules)'==''" xmlns="">
    <PropertyGroup>
      <EmbeddedWin32Manifest>$(ApplicationManifest)</EmbeddedWin32Manifest>
      <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
    </PropertyGroup>
    <!-- If PreferNativeArm64 is enabled, it searches for the same default.win32manifest  -->
    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true'">
      <Output TaskParameter="FrameworkVersion40Path" PropertyName="_FrameworkVersion40Path" />
    </GetFrameworkPath>
    <PropertyGroup>
      <EmbeddedWin32Manifest Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _SetPreferNativeArm64Win32ManifestProperties

    Populates Manifest with SupportedArchitectures and updates Win32Manifest property to be used later in the build.
    ============================================================
    -->
  <Target Name="_SetPreferNativeArm64Win32ManifestProperties" Condition=" '$(PreferNativeArm64)'=='true' and '$(NoWin32Manifest)'!='true'" DependsOnTargets="SetWin32ManifestProperties" xmlns="">
    <AddToWin32Manifest ApplicationManifest="$(Win32Manifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)">
      <Output TaskParameter="ManifestPath" PropertyName="_Win32Manifest" />
    </AddToWin32Manifest>
    <PropertyGroup>
      <Win32Manifest Condition="'$(_Win32Manifest)' != ''">$(_Win32Manifest)</Win32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateManifests Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        GenerateManifests

    Generates ClickOnce application and deployment manifests or a native manifest.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <GenerateManifestsDependsOn>
      SetWin32ManifestProperties;
      GenerateApplicationManifest;
      GenerateDeploymentManifest
    </GenerateManifestsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                  _GenerateResolvedDeploymentManifestEntryPoint

    Use the ResolveManifestFiles to generate the GenerateResolvedDeploymentManifestEntryPoint

    ============================================================
    -->
  <Target Name="_GenerateResolvedDeploymentManifestEntryPoint" xmlns="">
    <ItemGroup>
      <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'" />
    </ItemGroup>
    <ResolveManifestFiles TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" SigningManifests="$(SignManifests)" DeploymentManifestEntryPoint="@(ApplicationManifest)" PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
      <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint" />
    </ResolveManifestFiles>
  </Target>
  <Target Name="GenerateManifests" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!='' or '$(GenerateAppxManifest)' == 'true'" DependsOnTargets="$(GenerateManifestsDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        GenerateApplicationManifest

    Generates a ClickOnce or native application manifest.
    An application manifest specifies declarative application identity, dependency and security information.

        [IN]
        $(_DeploymentBaseManifest) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(_DeploymentManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(_DeploymentManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        $(_DeploymentManifestType) - Type of manifest to be generated, either "Native" or "ClickOnce".

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
    ============================================================
    -->
  <Target Name="GenerateApplicationManifest" DependsOnTargets="&#xD;&#xA;            _DeploymentSetClickOnceVersions;&#xD;&#xA;            _DeploymentGenerateLauncher;&#xD;&#xA;            _DeploymentComputeNativeManifestInfo;&#xD;&#xA;            _DeploymentComputeClickOnceManifestInfo;&#xD;&#xA;            ResolveComReferences;&#xD;&#xA;            ResolveNativeReferences;&#xD;&#xA;            _GenerateResolvedDeploymentManifestEntryPoint" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(AppConfigWithTargetPath);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            @(ResolvedIsolatedComModules);&#xD;&#xA;            @(_DeploymentManifestDependencies);&#xD;&#xA;            @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;            @(_DeploymentManifestFiles)" Outputs="@(ApplicationManifest)" xmlns="">
    <RequiresFramework35SP1Assembly ReferencedAssemblies="@(Reference)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" TargetFrameworkVersion="$(TargetFrameworkVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" SigningManifests="$(SignManifests)" Assemblies="@(_DeploymentManifestDependencies)" DeploymentManifestEntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" Files="@(_DeploymentManifestFiles)" SuiteName="$(SuiteName)">
      <Output TaskParameter="RequiresMinimumFramework35SP1" PropertyName="_DeploymentRequiresMinimumFramework35SP1" />
    </RequiresFramework35SP1Assembly>
    <GenerateApplicationManifest AssemblyName="$(_DeploymentApplicationManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" ConfigFile="@(AppConfigWithTargetPath)" ClrVersion="$(ClrVersion)" Dependencies="@(_DeploymentManifestDependencies)" Description="$(Description)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" FileAssociations="@(FileAssociation)" Files="@(_DeploymentManifestFiles)" HostInBrowser="$(HostInBrowser)" IconFile="@(_DeploymentManifestIconFile)" InputManifest="$(_DeploymentBaseManifest)" IsolatedComReferences="@(ResolvedIsolatedComModules)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManifestType="$(_DeploymentManifestType)" MaxTargetPath="$(MaxTargetPath)" OutputManifest="@(ApplicationManifest)" OSVersion="$(OSVersion)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkSubset="$(TargetFrameworkSubset)" TargetFrameworkProfile="$(TargetFrameworkProfile)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)" UseApplicationTrust="$(UseApplicationTrust)">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateApplicationManifest>
    <AddToWin32Manifest Condition="'$(PreferNativeArm64)'=='true'" ApplicationManifest="@(ApplicationManifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)" />
    <PropertyGroup>
      <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentSetClickOnceVersions

    Sets ClickOnce versions
    ============================================================
    -->
  <Target Name="_DeploymentSetClickOnceVersions" Condition="'$(GenerateClickOnceManifests)'=='true'" xmlns="">
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkMoniker>$(TargetFrameworkMoniker)</_DeploymentManifestTargetFrameworkMoniker>
      <_DeploymentManifestTargetFrameworkVersion>$(TargetFrameworkVersion)</_DeploymentManifestTargetFrameworkVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateLauncher

    Generates Launcher if needed
    ============================================================
    -->
  <Target Name="_DeploymentGenerateLauncher" Condition="'$(GenerateClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true'" xmlns="">
    <!--
      If apphost based built EXE is found, use that as the Launcher.exe's entry point otherwise
      use the built DLL as the entry point
    -->
    <ItemGroup Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')">
      <EntryPointForLauncher Include="$(AppHostIntermediatePath)" TargetPath="$(AssemblyName).exe" />
      <ContentWithTargetPath Include="@(EntryPointForLauncher)" />
    </ItemGroup>
    <ItemGroup Condition="'$(EntryPointForLauncher)'==''">
      <EntryPointForLauncher Include="$(_DeploymentManifestEntryPoint)" />
    </ItemGroup>
    <!-- Generates Launcher and obtains its Framework version and moniker -->
    <GenerateLauncher AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(EntryPointForLauncher)" OutputPath="$(IntermediateOutputPath)" VisualStudioVersion="$(VisualStudioVersion)">
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentManifestLauncherEntryPoint" />
    </GenerateLauncher>
    <!--
      .NET Core ClickOnce deployments use Launcher, which targets .NET FX 4.5 as the minimum
      supported ClickOnce runtime version on target user's machine.

      TargetFramework Verion and Moniker properties are used in Deployment manifest generation
      task to set compatibleFrameworks element, which needs to match Launcher's target version.

      Version can be overriden with DeploymentManifestTargetFrameworkVersionOverride property.
    -->
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' == ''">v4.5</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' != ''">$(DeploymentManifestTargetFrameworkVersionOverride)</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkMoniker>.NETFramework,Version=$(_DeploymentManifestTargetFrameworkVersion)</_DeploymentManifestTargetFrameworkMoniker>
    </PropertyGroup>
    <!-- Sign Launcher EXE -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestLauncherEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign the original ClickOnce entrypoint -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign apphost.exe if it's the entrypoint for the Launcher.exe. This is the case in loose file publish -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(AppHostIntermediatePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(UseAppHost)' == 'true' and '$(PublishSingleFile)' != 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')" />
    <!--
      Replace entry-point with Launcher and move original project's entry-point to content group.
    -->
    <ItemGroup>
      <ContentWithTargetPath Include="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeNativeManifestInfo

    Compute info for native manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeNativeManifestInfo" Condition="'$(GenerateClickOnceManifests)'!='true'" xmlns="">
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies" />
    </ResolveManifestFiles>
    <PropertyGroup>
      <_DeploymentManifestType>Native</_DeploymentManifestType>
    </PropertyGroup>
    <!-- Obtain manifest version from the built assembly -->
    <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_IntermediateAssemblyIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_DeploymentManifestVersion>@(_IntermediateAssemblyIdentity->'%(Version)')</_DeploymentManifestVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeClickOnceManifestInfo

    Compute info for  ClickOnce manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeClickOnceManifestInfo" Condition="'$(GenerateClickOnceManifests)'=='true'" DependsOnTargets="$(DeploymentComputeClickOnceManifestInfoDependsOn)" xmlns="">
    <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
    <ItemGroup>
      <_SGenDllsRelatedToCurrentDll Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
      <_SGenDllsRelatedToCurrentDll Include="@(SerializationAssembly->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <ItemGroup Condition="!exists('$(ProjectLockFile)')">
      <_CopyLocalFalseRefPaths Include="@(ReferencePath)" Condition="'%(CopyLocal)' == 'false'" />
      <_CopyLocalFalseRefPathsWithExclusion Include="@(_CopyLocalFalseRefPaths)" Exclude="@(ReferenceCopyLocalPaths);@(_NETStandardLibraryNETFrameworkLib)" />
    </ItemGroup>
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ClickOnceSatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
    </ItemGroup>
    <!-- Flag primary dependencies-certain warnings emitted during application manifest generation apply only to them. -->
    <ItemGroup>
      <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)" Condition="('%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md') and ('%(ReferenceCopyLocalPaths.CopyToPublishDirectory)' != 'false')">
        <IsPrimary>true</IsPrimary>
      </_DeploymentReferencePaths>
      <_DeploymentReferencePaths Include="@(_CopyLocalFalseRefPathsWithExclusion)" />
    </ItemGroup>
    <!-- Include managed references in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Include="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly);@(ReferenceCOMWrappersToCopyLocal)" Exclude="@(_ClickOnceSatelliteAssemblies);@(_ReferenceScatterPaths);@(_ExcludedAssembliesFromManifestGeneration)" />
    </ItemGroup>
    <!-- Include the following files in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <!--
      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in
      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems
      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the
      ResolvePackageAssets target in dotnet/sdk
      -->
      <_ClickOnceRuntimeCopyLocalItems Include="@(RuntimeTargetsCopyLocalItems)" Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
      <!--
        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceTransitiveContentItemsTemp>
      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <!--
        ClickOnce content items is union of transitive content items and content items from this project.
        We also exclude content items from this project that have set CopyToPublishDirectory to Never.
      -->
      <_ClickOnceContentItems Include="@(ContentWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never'))" />
      <_ClickOnceContentItems Include="@(_ClickOnceTransitiveContentItems)" />
      <!--
        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either
        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <!-- Include items from None group for publishing -->
      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent')">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceNoneItemsTemp>
      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <_ClickOnceFiles Include="@(_ClickOnceContentItems);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems)" />
      <!-- clear temporary item groups to free memory -->
      <_ClickOnceNoneItemsTemp Remove="@(_ClickOnceNoneItemsTemp)" />
      <_ClickOnceNoneItems Remove="@(_ClickOnceNoneItems)" />
      <_ClickOnceTransitiveContentItemsTemp Remove="@(_ClickOnceTransitiveContentItemsTemp)" />
      <_ClickOnceTransitiveContentItems Remove="@(_ClickOnceTransitiveContentItems)" />
      <_ClickOnceContentItems Remove="@(_ClickOnceContentItems)" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_ClickOnceRuntimeCopyLocalItems)" />
    </ItemGroup>
    <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <_ClickOnceFiles Include="$(PublishedSingleFilePath);@(_DeploymentManifestIconFile)" />
      <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)" />
      <!-- Include file association icons from Content as loose files -->
      <_FileAssociationIcons Include="%(FileAssociation.DefaultIcon)" />
      <_ClickOnceFiles Include="@(ContentWithTargetPath)" Condition="'%(Identity)'=='@(_FileAssociationIcons)'" />
    </ItemGroup>
    <!-- For single file publish in .net core app, sign the SF EXE if signing is enabled -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(PublishedSingleFilePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'" />
    <!--
    If ReadyToRun is enabled in loose files scenario, we need to remove entries of the IL images that have gone through R2R
    compiler and replace them with the entries for their R2R images. The R2R application image also needs to be signed if necessary.
    -->
    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Include="@(_ReadyToRunFilesToPublish)" />
      <_ClickOnceTargetFile Include="@(_ReadyToRunFilesToPublish)" Condition="'%(Filename)%(Extension)' == '$(TargetFileName)'" />
    </ItemGroup>
    <!-- Sign application image created by R2R -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_ClickOnceTargetFile)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)' == 'true' and '$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'" />
    <!-- Copy the application executable from Obj folder to app.publish folder.
    This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
    <Copy SourceFiles="@(_DeploymentManifestEntryPoint)" DestinationFolder="$(ClickOncePublishDir)">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentClickOnceApplicationExecutable" />
    </Copy>
    <!-- Sign the application executable located in app.publish folder.  Signing this file is done to comply with SmartScreen. -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentClickOnceApplicationExecutable)" Condition="'$(_DeploymentResolvedManifestCertificateThumbprint)'!='' and '$(_DeploymentSignClickOnceManifests)'=='true' and '$(TargetExt)' == '.exe'" />
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(_DeploymentClickOnceApplicationExecutable)" ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)" Files="@(_ClickOnceFiles)" IsSelfContainedPublish="$(SelfContained)" IsSingleFilePublish="$(PublishSingleFile)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManagedAssemblies="@(_ManifestManagedReferences)" NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)" PublishFiles="@(PublishFile)" RuntimePackAssets="@(RuntimePackAsset)" SatelliteAssemblies="@(_ClickOnceSatelliteAssemblies)" SigningManifests="$(SignManifests)" TargetCulture="$(TargetCulture)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependenciesUnfiltered" />
      <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles" />
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentResolvedManifestEntryPoint" />
    </ResolveManifestFiles>
    <!-- We have to filter items out of the dependencies that have neither CopyLocal set to true, -->
    <!-- nor the dependency type manually set to 'Install'.                                       -->
    <ItemGroup>
      <_DeploymentManifestDependencies Include="@(_DeploymentManifestDependenciesUnfiltered)" Condition="!('%(_DeploymentManifestDependenciesUnfiltered.CopyLocal)' == 'false' And '%(_DeploymentManifestDependenciesUnfiltered.DependencyType)' != 'Install')" />
    </ItemGroup>
    <PropertyGroup>
      <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
    </PropertyGroup>
    <!--
      Manifest platform should always be MSIL for Launcher-based deployments, as the Launcher is MSIL.
      Do not set _DeploymentPlatformTarget property in Launcher case - this is interpreted as MSIL,
      by GenerateApplicationManifest and GenerateDeploymentManifest tasks.
      Otherwise, set it to PlatformTarget.
    -->
    <PropertyGroup>
      <_DeploymentPlatformTarget Condition="'$(_DeploymentLauncherBased)' != 'true'">$(PlatformTarget)</_DeploymentPlatformTarget>
    </PropertyGroup>
    <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion" />
    </FormatVersion>
    <FormatUrl InputUrl="$(_DeploymentUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedDeploymentUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(SupportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedSupportUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(ErrorReportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedErrorReportUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateTrustInfo

    Generates the application permission set for inclusion in the generated ClickOnce application manifest.
    ============================================================
    -->
  <Target Name="_DeploymentGenerateTrustInfo" Condition="'$(TargetZone)'!=''" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            " Outputs="@(_DeploymentIntermediateTrustInfoFile)" xmlns="">
    <GenerateTrustInfo BaseManifest="$(_DeploymentBaseManifest)" ApplicationDependencies="@(ReferencePath);@(ReferenceDependencyPaths)" ExcludedPermissions="$(ExcludedPermissions)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetZone="$(TargetZone)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)">
      <Output TaskParameter="TrustInfoFile" ItemName="FileWrites" />
    </GenerateTrustInfo>
  </Target>
  <!--
    ============================================================
                                        GenerateDeploymentManifest

    Generates a ClickOnce deployment manifest.
    An deployment manifest specifies declarative application identity and application update information.
    ============================================================
    -->
  <Target Name="GenerateDeploymentManifest" DependsOnTargets="GenerateApplicationManifest" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(ApplicationManifest)&#xD;&#xA;            " Outputs="@(DeployManifest)" xmlns="">
    <GenerateDeploymentManifest AssemblyName="$(_DeploymentDeployManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" DeploymentUrl="$(_DeploymentFormattedDeploymentUrl)" Description="$(Description)" DisallowUrlActivation="$(DisallowUrlActivation)" EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" Install="$(Install)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" MapFileExtensions="$(MapFileExtensions)" MaxTargetPath="$(MaxTargetPath)" MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)" OutputManifest="@(DeployManifest)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TargetFrameworkMoniker="$(_DeploymentManifestTargetFrameworkMoniker)" TrustUrlParameters="$(TrustUrlParameters)" UpdateEnabled="$(UpdateEnabled)" UpdateInterval="$(_DeploymentBuiltUpdateInterval)" UpdateMode="$(UpdateMode)" UpdateUnit="$(_DeploymentBuiltUpdateIntervalUnits)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateDeploymentManifest>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForRun Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <SkipCopyUnchangedFiles Condition="'$(SkipCopyUnchangedFiles)' == ''">true</SkipCopyUnchangedFiles>
    <UseCommonOutputDirectory Condition="'$(UseCommonOutputDirectory)' == ''">false</UseCommonOutputDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepareForRun

    Copy the build outputs to the final directory if they have changed.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareForRunDependsOn>
      CopyFilesToOutputDirectory
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForRun" DependsOnTargets="$(PrepareForRunDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        CopyFilesToOutputDirectory

    Copy all build outputs, satellites and other necessary files to the final directory.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <!-- By default we're not using Hard or Symbolic Links to copy to the output directory, and never when building in VS -->
    <CreateHardLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateHardLinksForCopyAdditionalFilesIfPossible>
    <CreateSymbolicLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateSymbolicLinksForCopyAdditionalFilesIfPossible>
  </PropertyGroup>
  <Target Name="CopyFilesToOutputDirectory" DependsOnTargets="&#xD;&#xA;            ComputeIntermediateSatelliteAssemblies;&#xD;&#xA;            _CopyFilesMarkedCopyLocal;&#xD;&#xA;            _CopySourceItemsToOutputDirectory;&#xD;&#xA;            _CopyAppConfigFile;&#xD;&#xA;            _CopyManifestFiles;&#xD;&#xA;            _CheckForCompileOutputs;&#xD;&#xA;            _SGenCheckForOutputs" xmlns="">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
      <ErrorIfLinkFailsForCopyFilesToOutputDirectory Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)' == ''">false</ErrorIfLinkFailsForCopyFilesToOutputDirectory>
    </PropertyGroup>
    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory Condition="'$(CopyDocumentationFileToOutputDirectory)'==''">true</CopyDocumentationFileToOutputDirectory>
    </PropertyGroup>
    <!-- Copy the build product (.dll or .exe). -->
    <Copy SourceFiles="@(IntermediateAssembly)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="MainAssembly" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the reference assembly build product (.dll or .exe). -->
    <CopyRefAssembly SourcePath="@(IntermediateRefAssembly)" DestinationPath="$(TargetRefPath)" Condition="'$(ProduceReferenceAssembly)' == 'true' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationPath" ItemName="ReferenceAssembly" />
      <Output TaskParameter="DestinationPath" ItemName="FileWrites" />
    </CopyRefAssembly>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)'!='true'" />
    <!-- Copy the additional modules. -->
    <Copy SourceFiles="@(AddModules)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(AddModules)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the serialization assembly if it exists. -->
    <Copy SourceFiles="$(IntermediateOutputPath)$(_SGenDllName)" DestinationFiles="$(OutDir)$(_SGenDllName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_SGenDllCreated)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the debug information file (.pdb), if any -->
    <Copy SourceFiles="@(_DebugSymbolsIntermediatePath)" DestinationFiles="@(_DebugSymbolsOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the resulting XML documentation file, if any. -->
    <Copy SourceFiles="@(DocFileItem)" DestinationFiles="@(FinalDocFile)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DocumentationFileProduced)'=='true' and '$(CopyDocumentationFileToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy satellite assemblies. -->
    <Copy SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath)" DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'@(IntermediateSatelliteAssembliesWithTargetPath)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!--
        Copy COM reference wrappers, isolated COM references, COM references included by
        native (manifest) references, native (manifest) reference files themselves.
        -->
    <Copy SourceFiles="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(ReferenceComWrappersToCopyLocal)' != '' or '@(ResolvedIsolatedComModules)' != '' or '@(_DeploymentLooseManifestFile)' != '' or '@(NativeReferenceFile)' != '' ">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
    <!-- Copy the build product of WinMDExp. -->
    <Copy SourceFiles="@(WinMDExpArtifacts)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '@(WinMDExpArtifacts)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
      <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
    </Copy>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
  </Target>
  <!--
    ============================================================
                                        _CopyFilesMarkedCopyLocal

    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    ============================================================
    -->
  <Target Name="_CopyFilesMarkedCopyLocal" Condition="'@(ReferenceCopyLocalPaths)' != ''" xmlns="">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyLocalIfPossible)' == ''">false</CreateHardLinksForCopyLocalIfPossible>
      <CreateSymbolicLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyLocalIfPossible)' == ''">false</CreateSymbolicLinksForCopyLocalIfPossible>
    </PropertyGroup>
    <Copy SourceFiles="@(ReferenceCopyLocalPaths)" DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyLocalIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyLocalIfPossible)" Condition="'$(UseCommonOutputDirectory)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
      <Output TaskParameter="CopiedFiles" ItemName="ReferencesCopiedInThisBuild" />
      <Output TaskParameter="WroteAtLeastOneFile" PropertyName="WroteAtLeastOneFile" />
    </Copy>
    <!-- If this project produces reference assemblies *and* copied (possibly transitive)
         references on this build, subsequent builds of projects that depend on it must
         not be considered up to date, so touch this marker file that is considered an
         input to projects that reference this one. -->
    <Touch Files="@(CopyUpToDateMarker)" AlwaysCreate="true" Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
    <ItemGroup>
      <FileWrites Include="@(CopyUpToDateMarker)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopySourceItemsToOutputDirectory
    ============================================================
    -->
  <Target Name="_CopySourceItemsToOutputDirectory" DependsOnTargets="&#xD;&#xA;            GetCopyToOutputDirectoryItems;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectory;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectoryAlways;&#xD;&#xA;            _CopyDifferingSourceItemsToOutputDirectory" xmlns="" />
  <!--
    ============================================================
                                        GetCopyToOutputDirectoryItems

    Get all project items that may need to be transferred to the output directory.
    This includes baggage items from transitively referenced projects.

    As of 17.0, content items are copied transitively by default.
    Set `MSBuildCopyContentTransitively` to false to opt out.
    See https://github.com/dotnet/msbuild/pull/6622 for more info.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <_TargetsThatPrepareProjectReferences>_SplitProjectReferencesByFileExistence</_TargetsThatPrepareProjectReferences>
    <!--
      GetCopyToOutputDirectoryItems depends on an unspecified dependency _SplitProjectReferencesByFileExistence -> AssignProjectConfiguration (https://github.com/dotnet/msbuild/issues/4677).
      When the unspecified dependency does not happen by accident, content copying is only 1 level deep instead of transitive.
      This target enforces the dependency.
    -->
    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
    <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </_TargetsThatPrepareProjectReferences>
    <GetCopyToOutputDirectoryItemsDependsOn>
      AssignTargetPaths;
      $(_TargetsThatPrepareProjectReferences);
      _GetProjectReferenceTargetFrameworkProperties;
      _PopulateCommonStateForGetCopyToOutputDirectoryItems
    </GetCopyToOutputDirectoryItemsDependsOn>
    <!--
      Mitigation for https://github.com/dotnet/msbuild/issues/4677
      When MSBuildCopyContentTransitively == true, all content copying is transitive.
      When MSBuildCopyContentTransitively == false, content copying is 1 level deep.
      When MSBuildCopyContentTransitively != {true, false}, the legacy behaviour in https://github.com/dotnet/msbuild/issues/4677 manifests.
     -->
    <_RecursiveTargetForContentCopying>GetCopyToOutputDirectoryItems</_RecursiveTargetForContentCopying>
    <!-- Enforce 1 level deep content copying by replacing the recursive content target with the target that retrieves the content for the current project only. -->
    <_RecursiveTargetForContentCopying Condition=" '$(MSBuildCopyContentTransitively)' == 'false' ">_GetCopyToOutputDirectoryItemsFromThisProject</_RecursiveTargetForContentCopying>
  </PropertyGroup>
  <Target Name="_PopulateCommonStateForGetCopyToOutputDirectoryItems" xmlns="">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToOutputDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' ">
      <_GCTODIKeepDuplicates>false</_GCTODIKeepDuplicates>
      <_GCTODIKeepMetadata>CopyToOutputDirectory;TargetPath</_GCTODIKeepMetadata>
    </PropertyGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences" DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove" Returns="@(_CopyToOutputDirectoryTransitiveItems)" xmlns="">
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="$(_RecursiveTargetForContentCopying)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Remove="@(_AllChildProjectItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromThisProject" DependsOnTargets="AssignTargetPaths;_PopulateCommonStateForGetCopyToOutputDirectoryItems" Returns="@(_ThisProjectItemsToCopyToOutputDirectory)" xmlns="">
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
  </Target>
  <Target Name="GetCopyToOutputDirectoryItems" Returns="@(AllItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' " DependsOnTargets="$(GetCopyToOutputDirectoryItemsDependsOn)" xmlns="">
    <!-- Compose the content items as the union between transitive content items and content items from this project. -->
    <!-- Use CallTarget to avoid breaking targets that hook right before GetCopyToOutputDirectoryItems but expect to run after _GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences and _GetCopyToOutputDirectoryItemsFromThisProject -->
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences">
      <Output TaskParameter="TargetOutputs" ItemName="_TransitiveItemsToCopyToOutputDirectory" />
    </CallTarget>
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromThisProject">
      <Output TaskParameter="TargetOutputs" ItemName="_ThisProjectItemsToCopyToOutputDirectory" />
    </CallTarget>
    <ItemGroup Condition="'$(CopyConflictingTransitiveContent)' == 'false'">
      <_TransitiveItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" MatchOnMetadata="TargetPath" MatchOnMetadataOptions="PathLike" />
    </ItemGroup>
    <ItemGroup>
      <_TransitiveItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <!-- Append the items from this project last so that they will be copied last. -->
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_TransitiveItemsToCopyToOutputDirectoryAlways);@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_SourceItemsToCopyToOutputDirectory Include="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest);@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_SourceItemsToCopyToOutputDirectoryIfDifferent Include="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent);@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
      <AllItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToOutputDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectory->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'%(FullPath)')" />
      <!-- Empty intermediate items to release memory -->
      <_TransitiveItemsToCopyToOutputDirectoryAlways Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent Remove="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent)" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_ThisProjectItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent Remove="@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Default implementation of GetCopyToPublishDirectoryItems for projects that do not
    use Microsoft.NET.Sdk. It simply returns whatever GetCopyToOutputDirectoryItems
    does with CopyToPublishDirectory implied  by CopyToOutputDirectory, which is the
    same as Microsoft.NET.Sdk default when its CopyToPublishDirectory is not used.

    Microsoft.NET.Sdk projects  will override this to allow the publish output to be
    customized independently from the build output.

    Having a default implementation here allows the Microsoft.NET.Sdk Publish target
    to work when a Microsoft.NET.Sdk-based project references a non-Microsoft.NET.Sdk-based
    project.
    ============================================================
    -->
  <Target Name="GetCopyToPublishDirectoryItems" DependsOnTargets="GetCopyToOutputDirectoryItems" Returns="@(AllPublishItemsFullPathWithTargetPath)" xmlns="">
    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(AllItemsFullPathWithTargetPath)">
        <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
      </AllPublishItemsFullPathWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'PreserveNewest'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectory)' != '' " Inputs="@(_SourceItemsToCopyToOutputDirectory)" Outputs="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" xmlns="">
    <!--
        Not using SkipUnchangedFiles="true" because the items we pass in are already only those that have newer timestampts in the source (determined by _GetCopyToOutputDirectoryItemsFromThisProject).
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectory)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectoryAlways

    Copy files that have the CopyToOutputDirectory attribute set to 'Always'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectoryAlways" Condition=" '@(_SourceItemsToCopyToOutputDirectoryAlways)' != '' " xmlns="">
    <!--
        Not using SkipUnchangedFiles="true" by default for backwards compatibility.
        -->
    <PropertyGroup>
      <SkipUnchangedFilesOnCopyAlways Condition="'$(SkipUnchangedFilesOnCopyAlways)' == ''">false</SkipUnchangedFilesOnCopyAlways>
    </PropertyGroup>
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryAlways)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="$(SkipUnchangedFilesOnCopyAlways)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyDifferingSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'IfDifferent'.
    ============================================================
    -->
  <Target Name="_CopyDifferingSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectoryIfDifferent)' != '' " xmlns="">
    <!--
        Using SkipUnchangedFiles="true" because we want only differing files.
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="true" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyAppConfigFile

    Copy the application config file.
    ============================================================
    -->
  <Target Name="_CopyAppConfigFile" Condition=" '@(AppConfigWithTargetPath)' != '' " Inputs="@(AppConfigWithTargetPath)" Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" xmlns="">
    <!--
        Copy the application's .config file, if any.
        Not using SkipUnchangedFiles="true" because the application may want to change
        the app.config and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(AppConfigWithTargetPath)" DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ================================================================
                                         _CopyManifestFiles
    ================================================================

    Copy the built manifests (.exe.manifest, .application/.xbap) to the final directory.
    -->
  <Target Name="_CopyManifestFiles" Condition=" '$(_DeploymentCopyApplicationManifest)'=='true' or '$(GenerateClickOnceManifests)'=='true' " DependsOnTargets="PrepareForBuild" xmlns="">
    <Copy SourceFiles="@(ApplicationManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true' or '$(_DeploymentCopyApplicationManifest)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainApplicationManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(_DeploymentCopyApplicationManifest)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainApplicationManifest->'%(FullPath)')" />
    <Copy SourceFiles="@(DeployManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainDeployManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(GenerateClickOnceManifests)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainDeployManifest->'%(FullPath)')" />
  </Target>
  <!--
    ================================================================
                                         _CheckForCompileOutputs

    Checks each file output from the main "Compile" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_CheckForCompileOutputs" xmlns="">
    <!--Record the main compile outputs.-->
    <ItemGroup>
      <FileWrites Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')" />
      <FileWrites Include="@(IntermediateRefAssembly)" Condition="'$(ProduceReferenceAssembly)' == 'true' and Exists('@(IntermediateRefAssembly)')" />
    </ItemGroup>
    <!-- Record the .xml if one was produced. -->
    <PropertyGroup>
      <_DocumentationFileProduced Condition="!Exists('@(DocFileItem)')">false</_DocumentationFileProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(DocFileItem)" Condition="'$(_DocumentationFileProduced)'=='true'" />
    </ItemGroup>
    <!-- Record the .pdb if one was produced. -->
    <PropertyGroup>
      <_DebugSymbolsProduced Condition="!Exists('@(_DebugSymbolsIntermediatePath)')">false</_DebugSymbolsProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SGenCheckForOutputs

    Checks each file output from the "GenerateSerializationAssemblies" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_SGenCheckForOutputs" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" xmlns="">
    <!-- Record the serializer .dll if one was produced.-->
    <PropertyGroup>
      <_SGenDllCreated Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')">true</_SGenDllCreated>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(_SGenDllName)" Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedRegistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedRegistration

    Registers the main assembly for COM interop.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <UnmanagedRegistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedRegistration" Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'" DependsOnTargets="$(UnmanagedRegistrationDependsOn)" xmlns="">
    <PropertyGroup>
      <RegisterAssemblyMSBuildArchitecture Condition="'$(RegisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</RegisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(RegisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(RegisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</RegisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</RegisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <RegisterAssembly Assemblies="@(_OutputPathItem->'%(FullPath)$(TargetFileName)')" TypeLibFiles="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" AssemblyListFile="@(_UnmanagedRegistrationCache)" CreateCodeBase="true" MSBuildRuntime="$(RegisterAssemblyMSBuildRuntime)" MSBuildArchitecture="$(RegisterAssemblyMSBuildArchitecture)" Condition="!Exists('@(_UnmanagedRegistrationCache)')" />
    <ItemGroup>
      <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                IncrementalClean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        IncrementalClean

    Remove files that were produced in a prior build but weren't produced in the current build.
    The reason is that if, for example, the name of the .exe has changed we want to delete the
    old copy.

    Leave the Clean cache file containing only the files produced in the current build.
    ============================================================
    -->
  <Target Name="IncrementalClean" DependsOnTargets="$(IncrementalCleanDependsOn);_CleanGetCurrentAndPriorFileWrites" xmlns="">
    <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
    <ItemGroup>
      <_CleanOrphanFileWrites Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanCurrentFileWrites)" />
    </ItemGroup>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_CleanOrphanFileWritesInIntermediate);@(_CleanOrphanFileWritesInOutput)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanOrphanFilesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted or was outside
             the current final output and intermediate output directories. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterIncrementalClean Include="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)" Exclude="@(_CleanOrphanFilesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterIncrementalClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWritesAfterIncrementalClean" />
    </RemoveDuplicates>
    <!-- Write new list of current files back to disk, replacing the existing list.-->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)" Condition="'@(_CleanUnfilteredPriorFileWrites)'!='@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)'" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
  <Target Name="_CleanGetCurrentAndPriorFileWrites" DependsOnTargets="_CheckForCompileOutputs;_SGenCheckForOutputs" xmlns="">
    <!-- Read the list of files produced by a prior builds from disk. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites" />
    </ReadLinesFromFile>
    <!--
        Convert the list of references to the absolute paths so we can make valid comparisons
        across two lists
         -->
    <ConvertToAbsolutePath Paths="@(_ResolveAssemblyReferenceResolvedFiles)">
      <Output TaskParameter="AbsolutePaths" ItemName="_ResolveAssemblyReferenceResolvedFilesAbsolute" />
    </ConvertToAbsolutePath>
    <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
    <ItemGroup>
      <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
    <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="FileWrites" />
    </FindUnderPath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate" />
    </FindUnderPath>
    <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
    <ItemGroup>
      <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!-- Remove duplicates from files produced in this build. -->
    <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)">
      <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Clean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Clean

    Delete all intermediate and final build outputs.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CleanDependsOn>
      BeforeClean;
      UnmanagedUnregistration;
      CoreClean;
      CleanReferencedProjects;
      CleanPublishFolder;
      AfterClean
    </CleanDependsOn>
  </PropertyGroup>
  <Target Name="Clean" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(CleanDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeClean

    Redefine this target in your project in order to run tasks just before Clean.
    ============================================================
    -->
  <Target Name="BeforeClean" xmlns="" />
  <!--
    ============================================================
                                        AfterClean

    Redefine this target in your project in order to run tasks just after Clean.
    ============================================================
    -->
  <Target Name="AfterClean" xmlns="" />
  <!--
    ============================================================
                                        CleanReferencedProjects

    Call Clean target on all Referenced Projects.
    ============================================================
    -->
  <Target Name="CleanReferencedProjects" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <!--
        When building the project directly from the command-line, clean those referenced projects
        that exist on disk.  For IDE builds and command-line .SLN builds, the solution build manager
        takes care of this.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="Clean" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" BuildInParallel="$(BuildInParallel)" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <!--
    ============================================================
                                        CoreClean
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CoreCleanDependsOn />
  </PropertyGroup>
  <Target Name="CoreClean" DependsOnTargets="$(CoreCleanDependsOn)" xmlns="">
    <!-- First clean any explicitly specified cleanable files.
             Declare items of this type if you want Clean to delete them. -->
    <Delete Files="@(Clean)" TreatErrorsAsWarnings="true" />
    <!-- Read in list of files that were written to disk in past builds. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites" />
    </ReadLinesFromFile>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete those files. -->
    <Delete Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" WriteOnlyWhenDifferent="true" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
  <Target Name="_CleanRecordFileWrites" DependsOnTargets="_CleanGetCurrentAndPriorFileWrites" xmlns="">
    <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
    <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write merged file list back to disk, replacing existing contents. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueFileWrites)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <!--
    ============================================================
                                        CleanPublishFolder
    ============================================================
    -->
  <Target Name="CleanPublishFolder" xmlns="">
    <RemoveDir Directories="$(ClickOncePublishDir)" Condition="'$(ClickOncePublishDir)'=='$(OutputPath)app.publish\' and Exists('$(ClickOncePublishDir)')" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PostBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PostBuildEvent

    Run the post-build event. This step is driven by two parameters:

    (1) The $(RunPostBuildEvent) property is set by the user through the IDE and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The $(_AssemblyTimestampBeforeCompile) and $(_AssemblyTimestampAfterCompile) values are
        set by the _TimeStampBeforeCompile and _TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PostBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PostBuildEvent" Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')" DependsOnTargets="$(PostBuildEventDependsOn)" xmlns="">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Publish Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <DeploymentComputeClickOnceManifestInfoDependsOn>
      CleanPublishFolder;
      $(_RecursiveTargetForContentCopying);
      _DeploymentGenerateTrustInfo;
      $(DeploymentComputeClickOnceManifestInfoDependsOn)
    </DeploymentComputeClickOnceManifestInfoDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        Publish

    This target is only called when doing ClickOnce publishing outside the IDE, which implicitly builds before publishing.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishDependsOn Condition="'$(PublishableProject)'=='true'">
      SetGenerateManifests;
      Build;
      PublishOnly
    </PublishDependsOn>
    <PublishDependsOn Condition="'$(PublishableProject)'!='true'">
      _DeploymentUnpublishable
    </PublishDependsOn>
  </PropertyGroup>
  <Target Name="Publish" DependsOnTargets="$(PublishDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _DeploymentUnpublishable

    This target is used to block an attempt to ClickOnce publish a non-publishable project, such as a ClassLibrary, when building outside the IDE.
    ============================================================
    -->
  <Target Name="_DeploymentUnpublishable" xmlns="">
    <MSBuildInternalMessage ResourceName="CommonSdk.DeploymentUnpublishable" Severity="Message" />
  </Target>
  <!--
    ============================================================
                                        SetGenerateManifests

    This target simply assures the GenerateClickOnceManifests property is set whenever the publish target is invoked.
    ============================================================
    -->
  <Target Name="SetGenerateManifests" xmlns="">
    <MSBuildInternalMessage Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'" ResourceName="CommonSdk.GenerateManifestsOnlyForExe" Severity="Error" />
    <MSBuildInternalMessage Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(ManifestCertificateThumbprint)'=='' and '$(ManifestKeyFile)'==''" ResourceName="CommonSdk.SigningKeyRequired" Severity="Error" />
    <PropertyGroup>
      <GenerateClickOnceManifests>true</GenerateClickOnceManifests>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PublishOnly

    The "PublishOnly" target is intended for ClickOnce publishing inside the IDE, where the build has already been done
    by the BuildManager.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishOnlyDependsOn>
      SetGenerateManifests;
      PublishBuild;
      BeforePublish;
      GenerateManifests;
      CopyFilesToOutputDirectory;
      _CopyFilesToPublishFolder;
      _DeploymentGenerateBootstrapper;
      ResolveKeySource;
      _DeploymentSignClickOnceDeployment;
      AfterPublish
    </PublishOnlyDependsOn>
  </PropertyGroup>
  <Target Name="PublishOnly" DependsOnTargets="$(PublishOnlyDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforePublish

    Redefine this target in your project in order to run tasks just before Publish.
    ============================================================
    -->
  <Target Name="BeforePublish" xmlns="" />
  <!--
    ============================================================
                                        AfterPublish

    Redefine this target in your project in order to run tasks just after Publish.
    ============================================================
    -->
  <Target Name="AfterPublish" xmlns="" />
  <!--
    ============================================================
                                        PublishBuild

    Defines the set of targets that publishing is directly dependent on.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
    </PublishBuildDependsOn>
  </PropertyGroup>
  <Target Name="PublishBuild" DependsOnTargets="$(PublishBuildDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _CopyFilesToPublishFolder
    ============================================================
    -->
  <Target Name="_CopyFilesToPublishFolder" xmlns="">
    <!-- Compute name of application folder, which includes the assembly name plus formatted application version.
             The application version is formatted to use "_" in place of "." chars (i.e. "1_0_0_0" instead of "1.0.0.0").
             This is done because some servers misinterpret "." as a file extension. -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)" FormatType="Path">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentApplicationVersionFragment" />
    </FormatVersion>
    <PropertyGroup>
      <_DeploymentApplicationFolderName>Application Files\$(AssemblyName)_$(_DeploymentApplicationVersionFragment)</_DeploymentApplicationFolderName>
      <_DeploymentApplicationDir>$(ClickOncePublishDir)$(_DeploymentApplicationFolderName)\</_DeploymentApplicationDir>
    </PropertyGroup>
    <PropertyGroup>
      <!-- By default we're not using Hard or Symbolic Links to copy to the publish directory, and never when building in VS -->
      <CreateHardLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForPublishFilesIfPossible)' == ''">false</CreateHardLinksForPublishFilesIfPossible>
      <CreateSymbolicLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForPublishFilesIfPossible)' == ''">false</CreateSymbolicLinksForPublishFilesIfPossible>
    </PropertyGroup>
    <!-- Copy files to publish folder -->
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xD;&#xA;                @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;                @(_DeploymentManifestFiles);&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal);&#xD;&#xA;                @(ResolvedIsolatedComModules);&#xD;&#xA;                @(_DeploymentLooseManifestFile)" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xD;&#xA;                @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentManifestFiles->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ResolvedIsolatedComModules->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentLooseManifestFile->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <Copy SourceFiles="@(_DeploymentManifestDependencies)" DestinationFiles="@(_DeploymentManifestDependencies->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" Condition="'$(PublishSingleFile)' != 'true' and '%(_DeploymentManifestDependencies.DependencyType)'=='Install'" />
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ReferenceScatterPaths)" DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" />
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <PublishedSingleFileToBeCopied Include="@(_DeploymentManifestFiles)" />
    </ItemGroup>
    <!-- For single-file publish case, we need to only copy the clickonce manifest, manifest entry point (launcher) and the SF EXE -->
    <Copy Condition="'$(PublishSingleFile)' == 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xD;&#xA;                 @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;                 @(PublishedSingleFileToBeCopied);" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xD;&#xA;                 @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                 @(PublishedSingleFileToBeCopied->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(_DeploymentComponentsUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedComponentsUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateBootstrapper
    ============================================================
    -->
  <Target Name="_DeploymentGenerateBootstrapper" xmlns="">
    <!-- Build setup.exe bootstrapper and copy referenced packages -->
    <GenerateBootstrapper ApplicationFile="$(TargetDeployManifestFileName)" ApplicationName="$(AssemblyName)" ApplicationUrl="$(_DeploymentFormattedApplicationUrl)" BootstrapperItems="@(BootstrapperPackage)" ComponentsLocation="$(BootstrapperComponentsLocation)" ComponentsUrl="$(_DeploymentFormattedComponentsUrl)" Culture="$(TargetCulture)" FallbackCulture="$(FallbackCulture)" OutputPath="$(ClickOncePublishDir)" SupportUrl="$(_DeploymentFormattedSupportUrl)" Path="$(GenerateBootstrapperSdkPath)" VisualStudioVersion="$(VisualStudioVersion)" Condition="'$(BootstrapperEnabled)'=='true'" />
  </Target>
  <!--
    ============================================================
                                        _DeploymentSignClickOnceDeployment
    ============================================================
    -->
  <Target Name="_DeploymentSignClickOnceDeployment" xmlns="">
    <!-- Sign manifests and the bootstrapper -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Update entry point path in deploy manifest -->
    <UpdateManifest ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" InputManifest="$(OutDir)$(TargetDeployManifestFileName)" OutputManifest="$(ClickOncePublishDir)$(TargetDeployManifestFileName)">
      <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest" />
    </UpdateManifest>
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)$(TargetDeployManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)setup.exe" Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroups Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        AllProjectOutputGroups

    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    ============================================================
    -->
  <Target Name="AllProjectOutputGroups" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroup;&#xD;&#xA;            DebugSymbolsProjectOutputGroup;&#xD;&#xA;            DocumentationProjectOutputGroup;&#xD;&#xA;            SatelliteDllsProjectOutputGroup;&#xD;&#xA;            SourceFilesProjectOutputGroup;&#xD;&#xA;            ContentFilesProjectOutputGroup;&#xD;&#xA;            SGenFilesOutputGroup" xmlns="" />
  <!--
    This is the key output for the BuiltProjectOutputGroup and is meant to be read directly from the IDE.
    Reading an item is faster than invoking a target.
    -->
  <ItemGroup Condition=" '$(OutputType)' != 'winmdobj' " xmlns="">
    <BuiltProjectOutputGroupKeyOutput Include="@(IntermediateAssembly->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
      <COM2REG Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'">true</COM2REG>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <ItemGroup Condition=" '$(OutputType)' == 'winmdobj' " xmlns="">
    <WinMDExpOutputWindowsMetadataFileItem Include="$(_IntermediateWindowsMetadataPath)" Condition="'$(_IntermediateWindowsMetadataPath)' != ''" />
    <BuiltProjectOutputGroupKeyOutput Include="@(WinMDExpOutputWindowsMetadataFileItem->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <!--
    ============================================================
                                        BuiltProjectOutputGroup
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
    <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroup" Returns="@(BuiltProjectOutputGroupOutput)" DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)" xmlns="">
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="@(BuiltProjectOutputGroupKeyOutput)" />
    </ItemGroup>
    <!-- This item represents the app.config file -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)" Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
        <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
        <TargetPath>$(TargetFileName).config</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' " />
      <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' " />
    </ItemGroup>
    <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="('@(NativeReference)'!='' or '@(_IsolatedComReference)'!='') And Exists('$(OutDir)$(_DeploymentTargetApplicationManifestFileName)')">
        <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
      </BuiltProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroup

    This target performs population of the Debug Symbols project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DebugSymbolsProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'" xmlns="">
    <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
      <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
    <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
    <DebugSymbolsProjectOutputGroupOutput Include="@(WinMDExpOutputPdbItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputPdbItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DebugSymbolsProjectOutputGroup" Returns="@(DebugSymbolsProjectOutputGroupOutput)" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        DocumentationProjectOutputGroup

    This target performs population of the Documentation project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DocumentationProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'" xmlns="">
    <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
      <FinalOutputPath>@(FinalDocFile->'%(FullPath)')</FinalOutputPath>
      <IsKeyOutput>true</IsKeyOutput>
      <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
    <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
    <DocumentationProjectOutputGroupOutput Include="@(WinMDOutputDocumentationFileItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputDocItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DocumentationProjectOutputGroup" Returns="@(DocumentationProjectOutputGroupOutput)" DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroup

    This target performs population of the Satellite Files project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SatelliteDllsProjectOutputGroupDependsOn>$(SatelliteDllsProjectOutputGroupDependsOn);PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroup" Returns="@(SatelliteDllsProjectOutputGroupOutput)" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependsOn)" xmlns="">
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutputIntermediate Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.WithCulture)' == 'true'">
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
        <Culture>%(EmbeddedResource.Culture)</Culture>
      </SatelliteDllsProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <FinalOutputPath Condition=" '%(SatelliteDllsProjectOutputGroupOutputIntermediate.FinalOutputPath)' == '' ">$(TargetDir)%(SatelliteDllsProjectOutputGroupOutputIntermediate.TargetPath)</FinalOutputPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>%(SatelliteDllsProjectOutputGroupOutputIntermediate.Identity)</OriginalItemSpec>
      </SatelliteDllsProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SourceFilesProjectOutputGroup

    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SourceFilesProjectOutputGroup" Returns="@(SourceFilesProjectOutputGroupOutput)" DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)" xmlns="">
    <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
      <SourceFilesProjectOutputGroupOutput Include="@(_CompileWithTargetPath->'%(FullPath)');@(EmbeddedResource->'%(FullPath)');@(_LicxFile->'%(FullPath)');@(AppConfigWithTargetPath->'%(FullPath)')" />
      <!-- Include the project file -->
      <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
        <TargetPath>$(ProjectFileName)</TargetPath>
      </SourceFilesProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- Get just the compile items -->
  <Target Name="GetCompile" Returns="@(Compile)" xmlns="" />
  <!--
    ============================================================
                                        ContentFilesProjectOutputGroup

    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ContentFilesProjectOutputGroup" Returns="@(ContentFilesProjectOutputGroupOutput)" DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)" xmlns="">
    <!-- Convert items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <ContentFilesProjectOutputGroupOutput Include="@(ContentWithTargetPath->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroup

    This target performs population of the GenerateSerializationAssemblies Files project output group.
    GenerateSerializationAssemblies files are those generated by the GenerateSerializationAssemblies target and task.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SGenFilesOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" xmlns="">
    <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
      <FinalOutputPath>@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')</FinalOutputPath>
      <TargetPath>$(_SGenDllName)</TargetPath>
    </SGenFilesOutputGroupOutput>
  </ItemGroup>
  <Target Name="SGenFilesOutputGroup" Returns="@(SGenFilesOutputGroupOutput)" DependsOnTargets="$(SGenFilesOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        SDKRelated Output groups

    These targets are to gather information from the SDKs.
    ============================================================
   -->
  <!-- Get the resolved SDK reference items -->
  <Target Name="GetResolvedSDKReferences" DependsOnTargets="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" xmlns="" />
  <!-- Target will return no results by default but will be populated by other targets elsewhere.
       Needed for certain build environments that import partial sets of targets. -->
  <Target Name="CollectReferencedNuGetPackages" Returns="@(ReferencedNuGetPackages)" xmlns="" />
  <!-- Get the TargetFrameworks that are supported for the Visual Studio TargetFramework drop down -->
  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)" xmlns="" />
  <!--
    ============================================================
                                        PriFilesOutputGroup

    This target performs population of the pri files output group
    ============================================================
    -->
  <Target Name="PriFilesOutputGroup" Condition="'@(_ReferenceRelatedPaths)' != ''" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(PriFilesOutputGroupOutput)" xmlns="">
    <!-- This item represents dependent pri file's -->
    <ItemGroup>
      <PriFilesOutputGroupOutput Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" />
    </ItemGroup>
  </Target>
  <PropertyGroup xmlns="">
    <SDKRedistOutputGroupDependsOn>ResolveSDKReferences;ExpandSDKReferences</SDKRedistOutputGroupDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        SDKRedistOutputGroup

    This target gathers the Redist folders from the SDKs which have been resolved.
    ============================================================
  -->
  <Target Name="SDKRedistOutputGroup" Returns="@(SDKRedistOutputGroupOutput)" DependsOnTargets="$(SDKRedistOutputGroupDependsOn)" xmlns="">
    <!-- This list starts with the least specific files to the most specific so that later files can overwrite earlier files-->
    <ItemGroup>
      <SDKRedistOutputGroupOutput Include="@(ResolvedRedistFiles)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroupsDependencies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CommonOutputGroupsDependsOn

    Dependencies common to many of the *OutputGroupDependencies targets.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CommonOutputGroupsDependsOn>
      $(CommonOutputGroupsDependsOn);
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </CommonOutputGroupsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        AllProjectOutputGroupsDependencies
    ============================================================
    -->
  <Target Name="AllProjectOutputGroupsDependencies" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroupDependencies;&#xD;&#xA;            DebugSymbolsProjectOutputGroupDependencies;&#xD;&#xA;            SatelliteDllsProjectOutputGroupDependencies;&#xD;&#xA;            DocumentationProjectOutputGroupDependencies;&#xD;&#xA;            SGenFilesOutputGroupDependencies" xmlns="" />
  <!--
    ============================================================
                                        BuiltProjectOutputGroupDependencies

    This target performs population of the Built project output group dependencies.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuiltProjectOutputGroupDependenciesDependsOn>
      $(BuiltProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </BuiltProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroupDependencies" DependsOnTargets="$(BuiltProjectOutputGroupDependenciesDependsOn)" Returns="@(BuiltProjectOutputGroupDependency)" xmlns="">
    <ItemGroup>
      <BuiltProjectOutputGroupDependency Include="@(ReferencePath->'%(FullPath)');&#xD;&#xA;                                                         @(ReferenceDependencyPaths->'%(FullPath)');&#xD;&#xA;                                                         @(NativeReferenceFile->'%(FullPath)');&#xD;&#xA;                                                         @(_DeploymentLooseManifestFile->'%(FullPath)');&#xD;&#xA;                                                         @(ResolvedIsolatedComModules->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroupDependencies

    This target performs population of the dependencies for the debug symbols project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DebugSymbolsProjectOutputGroupDependenciesDependsOn>
      $(DebugSymbolsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DebugSymbolsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DebugSymbolsProjectOutputGroupDependencies" Condition="'$(DebugSymbols)'!='false'" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependenciesDependsOn)" Returns="@(DebugSymbolsProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent PDB's -->
    <ItemGroup>
      <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroupDependencies

    This target performs population of the dependencies for the satellite files project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SatelliteDllsProjectOutputGroupDependenciesDependsOn>
      $(SatelliteDllsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SatelliteDllsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroupDependencies" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependenciesDependsOn)" Returns="@(SatelliteDllsProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent satellites -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupDependency Include="@(ReferenceSatellitePaths->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DocumentationProjectOutputGroupDependencies

    This target performs population of the dependencies for the documentation project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DocumentationProjectOutputGroupDependenciesDependsOn>
      $(DocumentationProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DocumentationProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DocumentationProjectOutputGroupDependencies" Condition="'$(DocumentationFile)'!=''" DependsOnTargets="$(DocumentationProjectOutputGroupDependenciesDependsOn)" Returns="@(DocumentationProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent XMLs -->
    <ItemGroup>
      <DocumentationProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.xml'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroupDependencies

    This target performs population of the dependencies for the GenerateSerializationAssemblies project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SGenFilesOutputGroupDependenciesDependsOn>
      $(SGenFilesOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SGenFilesOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SGenFilesOutputGroupDependencies" DependsOnTargets="$(SGenFilesOutputGroupDependenciesDependsOn)" Returns="@(SGenFilesOutputGroupDependency)" xmlns="">
    <!-- This item represents sgen xml serializer dll's -->
    <ItemGroup>
      <SGenFilesOutputGroupDependency Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ReferenceCopyLocalPathsOutputGroup

    Exposes the set of items that should be copied locally based on the project's references.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ReferenceCopyLocalPathsOutputGroupDependsOn>
      $(ReferenceCopyLocalPathsOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </ReferenceCopyLocalPathsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ReferenceCopyLocalPathsOutputGroup" DependsOnTargets="$(ReferenceCopyLocalPathsOutputGroupDependsOn)" Returns="@(ReferenceCopyLocalPathsOutputGroupOutput)" xmlns="">
    <ItemGroup>
      <ReferenceCopyLocalPathsOutputGroupOutput Include="@(ReferenceCopyLocalPaths)">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </ReferenceCopyLocalPathsOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
         DesignerRuntimeImplementationProjectOutputGroup

    Exposes build items to be used by designer. The default is empty, but
    SDKs can override it as appropriate. The empty stub is required so that
    the project system can always rely on calling it even if it is not
    overridden.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(DesignerRuntimeImplementationProjectOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesignerRuntimeImplementationProjectOutputGroup" DependsOnTargets="$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)" Returns="@(DesignerRuntimeImplementationProjectOutputGroupOutput)" xmlns="" />
  <!--
    ============================================================
                       .editorconfig support
    ============================================================
  -->
  <!-- Expose the set of potential .editorconfig files so the project system can
       retrieve them. -->
  <Target Name="GetPotentialEditorConfigFiles" Returns="@(PotentialEditorConfigFiles)" xmlns="" />
  <PropertyGroup xmlns="">
    <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeAnalysis\Microsoft.CodeAnalysis.targets</CodeAnalysisTargets>
  </PropertyGroup>
  <!--<Import Project="$(CodeAnalysisTargets)" Condition="Exists('$(CodeAnalysisTargets)')" />-->
  <!--<Import Project="$(ReportingServicesTargets)" Condition="Exists('$(ReportingServicesTargets)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.NETFramework.targets" Condition="('$(TargetFrameworkIdentifier)' == ''  or '$(TargetFrameworkIdentifier)' == '.NETFramework') and ('$(TargetRuntime)' == 'Managed')">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetFramework.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .net framework specific properties, items and targets. They are factored into a Microsoft.NETFramework.targets and Microsoft.NetFramework.props
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <NetFrameworkTargetsPath>$(MSBuildToolsPath)\Microsoft.NETFramework.CurrentVersion.targets</NetFrameworkTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetFrameworkTargetsPath)">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETFramework.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .net framework specific properties, items and targets. They are factored into a Microsoft.NETFramework.targets and Microsoft.NetFramework.props
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)' == ''">true</ImportByWildcardBeforeMicrosoftNetFrameworkTargets>
    <ImportByWildcardAfterMicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkTargets)' == ''">true</ImportByWildcardAfterMicrosoftNetFrameworkTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')" />-->
  <Target Name="GetFrameworkPaths" DependsOnTargets="$(GetFrameworkPathsDependsOn)" xmlns="">
    <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they
        now only depend on statically availiable values-->
    <ItemGroup>
      <_TargetFramework40DirectoryItem Include="$(MSBuildFrameworkToolsRoot)v4.0.30319" />
      <_TargetFramework35DirectoryItem Include="$(MSBuildFrameworkToolsRoot)v3.5" />
      <_TargetFramework30DirectoryItem Include="$(MSBuildFrameworkToolsRoot)v3.0" />
      <_TargetFramework20DirectoryItem Include="$(MSBuildFrameworkToolsRoot)v2.0.50727" />
      <_TargetedFrameworkDirectoryItem Condition="'$(TargetFrameworkVersion)' == 'v2.0'" Include="@(_TargetFramework20DirectoryItem)" />
      <_TargetedFrameworkDirectoryItem Condition="'$(TargetFrameworkVersion)' == 'v3.0' OR '$(TargetFrameworkVersion)' == 'v3.5'" Include="$(MSBuildFrameworkToolsRoot)\$(TargetFrameworkVersion)" />
      <_TargetedFrameworkDirectoryItem Condition="'@(_TargetedFrameworkDirectoryItem)' == ''" Include="@(_TargetFramework40DirectoryItem)" />
    </ItemGroup>
    <ItemGroup>
      <_CombinedTargetFrameworkDirectoriesItem Condition=" '$(TargetFrameworkVersion)' == 'v4.0' " Include="@(_TargetFramework40DirectoryItem)" />
      <_CombinedTargetFrameworkDirectoriesItem Condition=" '$(TargetFrameworkVersion)' == 'v3.5'" Include="@(_TargetFramework35DirectoryItem)" />
      <_CombinedTargetFrameworkDirectoriesItem Condition=" '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'" Include="@(_TargetFramework30DirectoryItem)" />
      <_CombinedTargetFrameworkDirectoriesItem Condition=" '$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'" Include="@(_TargetFramework20DirectoryItem)" />
      <_CombinedTargetFrameworkDirectoriesItem Condition=" '@(_CombinedTargetFrameworkDirectoriesItem)' == ''" Include="@(_TargetedFrameworkDirectoryItem)" />
    </ItemGroup>
    <PropertyGroup>
      <TargetFrameworkDirectory>@(_CombinedTargetFrameworkDirectoriesItem)</TargetFrameworkDirectory>
      <TargetFrameworkSDKDirectory>$(FrameworkSDKRoot)</TargetFrameworkSDKDirectory>
    </PropertyGroup>
    <ItemGroup>
      <_TargetFrameworkSDKDirectoryItem Include="$(TargetFrameworkSDKDirectory)" />
    </ItemGroup>
  </Target>
  <PropertyGroup xmlns="">
    <ResolveReferencesDependsOn>
      $(ResolveReferencesDependsOn);
      ImplicitlyExpandDesignTimeFacades
    </ResolveReferencesDependsOn>
    <ImplicitlyExpandDesignTimeFacadesDependsOn>
      $(ImplicitlyExpandDesignTimeFacadesDependsOn);
      GetReferenceAssemblyPaths
    </ImplicitlyExpandDesignTimeFacadesDependsOn>
  </PropertyGroup>
  <!-- Implicitly references all portable design-time facades if the user is referencing a System.Runtime-based portable library -->
  <Target Name="ImplicitlyExpandDesignTimeFacades" Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'" DependsOnTargets="$(ImplicitlyExpandDesignTimeFacadesDependsOn)" xmlns="">
    <PropertyGroup>
      <!-- Does one of our dependencies reference a System.Runtime-based portable library? -->
      <_HasReferenceToSystemRuntime Condition="'$(DependsOnSystemRuntime)' == 'true'">true</_HasReferenceToSystemRuntime>
      <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetPlatformIdentifier)' == 'Portable'">true</_HasReferenceToSystemRuntime>
      <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetFrameworkIdentifier)' == '.NETStandard' and '%(_ResolvedProjectReferencePaths.TargetFrameworkVersion)' &lt; '2.0'">true</_HasReferenceToSystemRuntime>
      <_HasReferenceToNETStandard Condition="'$(_DependsOnNETStandard)' == 'true'">true</_HasReferenceToNETStandard>
      <_HasReferenceToNETStandard Condition="'%(_ResolvedProjectReferencePaths.TargetFrameworkIdentifier)' == '.NETStandard' and '%(_ResolvedProjectReferencePaths.TargetFrameworkVersion)' &gt;= '2.0'">true</_HasReferenceToNETStandard>
    </PropertyGroup>
    <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true'">
      <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)*.dll" />
    </ItemGroup>
    <ItemGroup Condition="'$(_HasReferenceToNETStandard)' == 'true' And '$(_HasReferenceToSystemRuntime)' != 'true'">
      <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)netstandard.dll" Condition="Exists('%(DesignTimeFacadeDirectories.Identity)netstandard.dll')" />
    </ItemGroup>
    <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true' Or '$(_HasReferenceToNETStandard)' == 'true' ">
      <_DesignTimeFacadeAssemblies_Names Include="@(_DesignTimeFacadeAssemblies->'%(FileName)')">
        <OriginalIdentity>%(_DesignTimeFacadeAssemblies.Identity)</OriginalIdentity>
      </_DesignTimeFacadeAssemblies_Names>
      <_ReferencePath_Names Include="@(ReferencePath->'%(FileName)')">
        <OriginalIdentity>%(ReferencePath.Identity)</OriginalIdentity>
      </_ReferencePath_Names>
      <_DesignTimeFacadeAssemblies_Names Remove="@(_ReferencePath_Names)" />
      <ReferencePath Include="@(_DesignTimeFacadeAssemblies_Names->'%(OriginalIdentity)')">
        <WinMDFile>false</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ResolvedFrom>ImplicitlyExpandDesignTimeFacades</ResolvedFrom>
      </ReferencePath>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
    </ItemGroup>
  </Target>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetCompactFramework)' != 'true' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')" />-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' !=  'v3.0' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.NETFramework.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <ImportXamlTargets Condition="'$(ImportXamlTargets)'=='' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.Xaml.targets')">true</ImportXamlTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Xaml.targets" Condition="('$(ImportXamlTargets)' == 'true')" />-->
  <!-- imports Microsoft.WorkflowBuildExtensions.targets only if TargetFrameworkVersion is v4.5 or above or TargetFrameworkfVersion specified does not conform to the format of vX.X[.X.X] -->
  <!-- Underlying assumption is that there shouldn't be any other versions between v4.0.* and v4.5 -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5' and (!$([System.String]::IsNullOrEmpty('$(TargetFrameworkVersion)')) and !$(TargetFrameworkVersion.StartsWith('v4.0')))) and Exists('$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')" />-->
  <PropertyGroup xmlns="">
    <MsTestToolsTargets Condition="'$(MsTestToolsTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TeamTest\Microsoft.TeamTest.targets</MsTestToolsTargets>
  </PropertyGroup>
  <!--<Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />-->
  <PropertyGroup xmlns="">
    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'" />-->
  <!-- App packaging support -->
  <!--
    Following two targets are needed to be present in every project being built
    because the app packaging targets recursively scan all projects referenced
    from projects that generate app packages for them.
  -->
  <Target Name="CleanAppxPackage" xmlns="" />
  <Target Name="GetPackagingOutputs" xmlns="" />
  <PropertyGroup xmlns="">
    <MsAppxPackageTargets Condition="'$(MsAppxPackageTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\Microsoft.AppXPackage.Targets</MsAppxPackageTargets>
    <!-- Opt-out switch to allow disabling importing the 'AppxPackage' targets for UWP class libraries using modern .NET -->
    <EnableAppxPackageTargetsForUwpClassLibraries Condition="'$(EnableAppxPackageTargetsForUwpClassLibraries)' == ''">true</EnableAppxPackageTargetsForUwpClassLibraries>
  </PropertyGroup>
  <!--
    We want to import the 'AppXPackage' .targets in two scenarios:
      - For legacy UWP, in all cases (original behavior). These projects will always set 'WindowsAppContainer' by default.
      - For UWP (XAML) apps and libraries on modern .NET, we only enable this for class libraries. This allows the existing
        .appx tooling to take care of generating .pri resources without the need to pull in WinAppSDK or other external tools.
        We cannot use this for applications, because the rest of that tooling is not capable of handling modern .NET projects.
        In that case, we either leverage the tooling in WinAppSDK, or DesktopBridge (via a .wapproj project for packaging).
  -->
  <!--<Import Project="$(MsAppxPackageTargets)" Condition="('$(WindowsAppContainer)' == 'true' or ('$(UseUwpTools)' == 'true' and '$(OutputType)' == 'Library' and '$(EnableAppxPackageTargetsForUwpClassLibraries)' != 'false')) and Exists('$(MsAppxPackageTargets)')" />-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')" />-->
  <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
  <PropertyGroup xmlns="">
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetRestoreTargets)" Condition="'$(IsRestoreTargetsFileLoaded)' != 'true' and Exists('$(NuGetRestoreTargets)')">

C:\Program Files\dotnet\sdk\9.0.200\NuGet.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************

  This target file contains the NuGet Restore target for walking the project and reference graph
  and restoring dependencies from the graph.

  Ways to use this targets file:
  1. Invoke it directly and provide project file paths using $(RestoreGraphProjectInput).
  2. With a solution this may be used as a target in the metaproj.
  3. Import the targets file from a project.

  Restore flow summary:
  1. Top level projects (entry points) are determined.
  2. Each project and all of its project references are walked recursively.
  3. The project is evaluated for each $(TargetFramework). Items are created
     for project properties and dependencies. Each item is marked
     with the project it came from so that it can be matched up later.
  4. All restore items generated by the walk are grouped together by
     project and convert into a project spec.

  The result file contains:
  1. A list of projects to restore.
  2. The complete closure of all projects referenced (Includes project references that are not being restored directly).
  3. Package and project dependencies for each project.
  4. DotnetCliTool references
  -->
  <PropertyGroup>
    <!-- Mark that this target file has been loaded.  -->
    <IsRestoreTargetsFileLoaded>true</IsRestoreTargetsFileLoaded>
    <!-- Load NuGet.Build.Tasks.dll, this can be overridden to use a different version with $(RestoreTaskAssemblyFile) -->
    <RestoreTaskAssemblyFile Condition=" '$(RestoreTaskAssemblyFile)' == '' ">NuGet.Build.Tasks.dll</RestoreTaskAssemblyFile>
    <!-- Do not hide errors and warnings by default -->
    <HideWarningsAndErrors Condition=" '$(HideWarningsAndErrors)' == '' ">false</HideWarningsAndErrors>
    <!-- Recurse by default -->
    <RestoreRecursive Condition=" '$(RestoreRecursive)' == '' ">true</RestoreRecursive>
    <RestoreUseSkipNonexistentTargets Condition=" '$(RestoreUseSkipNonexistentTargets)' == '' ">true</RestoreUseSkipNonexistentTargets>
    <!-- RuntimeIdentifier compatibility check -->
    <ValidateRuntimeIdentifierCompatibility Condition=" '$(ValidateRuntimeIdentifierCompatibility)' == '' ">false</ValidateRuntimeIdentifierCompatibility>
    <!-- Error handling while walking projects -->
    <RestoreContinueOnError Condition=" '$(RestoreContinueOnError)' == '' ">WarnAndContinue</RestoreContinueOnError>
    <!-- Build in parallel -->
    <RestoreBuildInParallel Condition=" '$(BuildInParallel)' != '' ">$(BuildInParallel)</RestoreBuildInParallel>
    <RestoreBuildInParallel Condition=" '$(RestoreBuildInParallel)' == '' ">true</RestoreBuildInParallel>
    <!-- Check if the restore target was executed on a sln file -->
    <_RestoreSolutionFileUsed Condition=" '$(_RestoreSolutionFileUsed)' == '' AND '$(SolutionDir)' != '' AND $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' ">true</_RestoreSolutionFileUsed>
    <!-- We default to MSBuildInteractive. -->
    <NuGetInteractive Condition=" '$(NuGetInteractive)' == '' ">$(MSBuildInteractive)</NuGetInteractive>
    <!-- Mark that this targets file supports package download. -->
    <PackageDownloadSupported>true</PackageDownloadSupported>
    <!-- Mark that this targets file GetReferenceNearestTargetFrameworkTask task supports the TargetPlatformMoniker -->
    <GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>true</GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>
    <!-- Flag if the Central package file is enabled -->
    <_CentralPackageVersionsEnabled Condition="'$(ManagePackageVersionsCentrally)' == 'true' AND '$(CentralPackageVersionsFileImported)' == 'true'">true</_CentralPackageVersionsEnabled>
  </PropertyGroup>
  <!--
    Visual Studio's project property page requires defaults to be set to inform customers what the default values are.
    Project-system uses DefaultValueSourceLocation.AfterContext to detect when a customer's project changes the value, so these defaults must be set here in the targets file.
  -->
  <PropertyGroup>
    <!-- Enable NuGetAudit by default -->
    <NuGetAudit Condition=" '$(NuGetAudit)' == '' ">true</NuGetAudit>
    <!-- Report all severity vulnerabilities (low severity and higher). Allowed values are: low, moderate, high, critical -->
    <NuGetAuditLevel Condition=" '$(NuGetAuditLevel)' == '' ">low</NuGetAuditLevel>
    <!-- Report known vulnerabilities on direct and transitive dependencies, unless SdkAnalysisLevel (or equalivant) is lower than 9.0.100. Allowed values are: direct, all -->
    <NuGetAuditMode Condition=" '$(NuGetAuditMode)' == '' ">direct</NuGetAuditMode>
  </PropertyGroup>
  <PropertyGroup>
    <RestoreEnablePackagePruning Condition="$(RestoreEnablePackagePruning) == '' ">false</RestoreEnablePackagePruning>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Exclude packages from changing restore inputs.  -->
    <_GenerateRestoreGraphProjectEntryInputProperties>ExcludeRestorePackageImports=true</_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Standalone mode
         This is used by NuGet.exe to inject targets into the project that will be
         walked next. In normal /t:Restore mode this causes a duplicate import
         since NuGet.targets it loaded as part of MSBuild, there is should be
         skipped. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(RestoreUseCustomAfterTargets)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      NuGetRestoreTargets=$(MSBuildThisFileFullPath);
      RestoreUseCustomAfterTargets=$(RestoreUseCustomAfterTargets);
      CustomAfterMicrosoftCommonCrossTargetingTargets=$(MSBuildThisFileFullPath);
      CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
    </_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Include SolutionDir and SolutionName for solution restores and persist these properties during the walk. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(_RestoreSolutionFileUsed)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      _RestoreSolutionFileUsed=true;
      SolutionDir=$(SolutionDir);
      SolutionName=$(SolutionName);
      SolutionFileName=$(SolutionFileName);
      SolutionPath=$(SolutionPath);
      SolutionExt=$(SolutionExt);
    </_GenerateRestoreGraphProjectEntryInputProperties>
  </PropertyGroup>
  <ItemGroup Condition="'$(ManagePackageVersionsCentrally)' == 'true' And '$(RestoreEnableGlobalPackageReference)' != 'false'">
    <!--
        Add GlobalPackageReference items to the PackageReference item group with no version.

        Global package references only include the same assets as a development dependency (runtime; build; native; contentfiles; analyzers)
        because those kind of packages are the best candidate for a global package reference.  They are generally packages that
        extend the build.

        Global package references have all assets private because central package references are generally packages that provide
        versioning, signing, etc and should not flow to downstream dependencies.  Also, central package references are already
        referenced by every project in the tree so they don't need to be transitive.
      -->
    <PackageReference Include="@(GlobalPackageReference)" Version="" IncludeAssets="Runtime;Build;Native;contentFiles;Analyzers" PrivateAssets="All" />
    <!--
        Add GlobalPackageReference items to the PackageVersion item group with the version.
      -->
    <PackageVersion Include="@(GlobalPackageReference)" Version="%(Version)" />
  </ItemGroup>
  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.RestoreTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WriteRestoreGraphTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectJsonPathTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetCentralPackageVersionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageDownloadsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreFrameworkReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreNuGetAuditSuppressionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePrunePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreDotnetCliToolsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSolutionProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSettingsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WarnForInvalidProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetReferenceNearestTargetFrameworkTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectStyleTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.NuGetMessageTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.CheckForDuplicateNuGetItemsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetGlobalPropertyValueTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <!--
    ============================================================
    Restore
    Main entry point for restoring packages
    ============================================================
  -->
  <Target Name="Restore" DependsOnTargets="_GenerateRestoreGraph">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Call restore -->
    <RestoreTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreDisableParallel="$(RestoreDisableParallel)" RestoreNoCache="$(RestoreNoCache)" RestoreNoHttpCache="$(RestoreNoHttpCache)" RestoreIgnoreFailedSources="$(RestoreIgnoreFailedSources)" RestoreRecursive="$(RestoreRecursive)" RestoreForce="$(RestoreForce)" HideWarningsAndErrors="$(HideWarningsAndErrors)" Interactive="$(NuGetInteractive)" RestoreForceEvaluate="$(RestoreForceEvaluate)" RestorePackagesConfig="$(RestorePackagesConfig)" EmbedFilesInBinlog="$(RestoreEmbedFilesInBinlog)">
      <Output TaskParameter="EmbedInBinlog" ItemName="EmbedInBinlog" />
      <Output TaskParameter="ProjectsRestored" PropertyName="RestoreProjectCount" />
      <Output TaskParameter="ProjectsAlreadyUpToDate" PropertyName="RestoreSkippedCount" />
      <Output TaskParameter="ProjectsAudited" PropertyName="RestoreProjectsAuditedCount" />
    </RestoreTask>
  </Target>
  <!--
    ============================================================
    GenerateRestoreGraphFile
    Writes the output of _GenerateRestoreGraph to disk
    ============================================================
  -->
  <Target Name="GenerateRestoreGraphFile" DependsOnTargets="_GenerateRestoreGraph">
    <!-- Validate  -->
    <Error Condition="$(RestoreGraphOutputPath) == ''" Text="Missing RestoreGraphOutputPath property!" />
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Write file -->
    <WriteRestoreGraphTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreGraphOutputPath="$(RestoreGraphOutputPath)" RestoreRecursive="$(RestoreRecursive)" />
  </Target>
  <!--
    ============================================================
    CollectPackageReferences
    Gathers all PackageReference items from the project.
    This target may be used as an extension point to modify
    package references before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageReferences" Returns="@(PackageReference)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageReferencesContinueOnError>$(ContinueOnError)</CollectPackageReferencesContinueOnError>
      <CollectPackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageReference)" ItemName="PackageReference" LogCode="NU1504" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageReferences" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageReferences)' != ''">
      <PackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(DeduplicatedPackageReferences)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectCentralPackageVersions
    Gathers all PackageVersion items from the central package versions file.
    ============================================================
  -->
  <Target Name="CollectCentralPackageVersions" Returns="@(PackageVersion)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectCentralPackageVersionsContinueOnError>$(ContinueOnError)</CollectCentralPackageVersionsContinueOnError>
      <CollectCentralPackageVersionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectCentralPackageVersionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageVersion)" ItemName="PackageVersion" LogCode="NU1506" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectCentralPackageVersionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageVersions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageVersions)' != ''">
      <PackageVersion Remove="@(PackageVersion)" />
      <PackageVersion Include="@(DeduplicatedPackageVersions)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectPackageDownloads
    Gathers all PackageDownload items from the project.
    This target may be used as an extension point to modify
    package downloads before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageDownloads" Returns="@(PackageDownload)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageDownloadsContinueOnError>$(ContinueOnError)</CollectPackageDownloadsContinueOnError>
      <CollectPackageDownloadsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageDownloadsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageDownload)" ItemName="PackageDownload" LogCode="NU1505" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageDownloadsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageDownloads" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageDownloads)' != ''">
      <PackageDownload Remove="@(PackageDownload)" />
      <PackageDownload Include="@(DeduplicatedPackageDownloads)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectFrameworkReferences
    ============================================================
  -->
  <Target Name="CollectFrameworkReferences" Returns="@(_FrameworkReferenceForRestore)">
    <ItemGroup>
      <_FrameworkReferenceForRestore Include="@(FrameworkReference)" Condition="'%(FrameworkReference.IsTransitiveFrameworkReference)' != 'true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectNuGetAuditSuppressions
    Gathers all NuGetAuditSuppress items from the project.
    This target may be used as an extension point to modify
    advisory suppressions before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectNuGetAuditSuppressions" Returns="@(NuGetAuditSuppress)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectNuGetAuditSuppressionsContinueOnError>$(ContinueOnError)</CollectNuGetAuditSuppressionsContinueOnError>
      <CollectNuGetAuditSuppressionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectNuGetAuditSuppressionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Items="@(NuGetAuditSuppress)" ItemName="NuGetAuditSuppress" LogCode="NU1508" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectNuGetAuditSuppressionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedNuGetAuditSuppressions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedNuGetAuditSuppressions)' != ''">
      <NuGetAuditSuppress Remove="@(NuGetAuditSuppress)" />
      <NuGetAuditSuppress Include="@(DeduplicatedNuGetAuditSuppressions)" />
    </ItemGroup>
  </Target>
  <Target Name="CollectPrunePackageReferences" Returns="@(PrunePackageReference)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPrunePackageReferencesContinueOnError>$(ContinueOnError)</CollectPrunePackageReferencesContinueOnError>
      <CollectPrunePackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPrunePackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PrunePackageReference)" ItemName="PrunePackageReference" LogCode="NU1509" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPrunePackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPrunePackageReference" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPrunePackageReference)' != ''">
      <PrunePackageReference Remove="@(PrunePackageReference)" />
      <PrunePackageReference Include="@(DeduplicatedPrunePackageReference)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _CollectRestoreInputs
    Runs all the 'Collect' targets
    ============================================================
  -->
  <Target Name="_CollectRestoreInputs" DependsOnTargets="CollectPackageReferences;CollectPackageDownloads;CollectFrameworkReferences;CollectCentralPackageVersions;CollectNuGetAuditSuppressions;CollectPrunePackageReferences" />
  <!--
    ============================================================
    _LoadRestoreGraphEntryPoints
    Find project entry points and load them into items.
    ============================================================
  -->
  <Target Name="_LoadRestoreGraphEntryPoints" Returns="@(RestoreGraphProjectInputItems)">
    <!-- Allow overriding items with RestoreGraphProjectInput -->
    <ItemGroup Condition=" @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(RestoreGraphProjectInput)" />
    </ItemGroup>
    <!-- Project case -->
    <ItemGroup Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) != 'true' AND @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Solution case -->
    <GetRestoreSolutionProjectsTask Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' AND @(RestoreGraphProjectInputItems) == '' " ProjectReferences="@(ProjectReference)" SolutionFilePath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="OutputProjectReferences" ItemName="RestoreGraphProjectInputItems" />
    </GetRestoreSolutionProjectsTask>
  </Target>
  <!--
    ============================================================
    _FilterRestoreGraphProjectInputItems
    Filter out unsupported project entry points.
    ============================================================
  -->
  <Target Name="_FilterRestoreGraphProjectInputItems" DependsOnTargets="_LoadRestoreGraphEntryPoints" Returns="@(FilteredRestoreGraphProjectInputItems)">
    <PropertyGroup>
      <RestoreProjectFilterMode Condition=" '$(RestoreProjectFilterMode)' == '' ">exclusionlist</RestoreProjectFilterMode>
    </PropertyGroup>
    <!-- Filter to a list of known supported types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' == '.csproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vbproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.fsproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.nuproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.proj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.msbuildproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vcxproj' " />
    </ItemGroup>
    <!-- Filter out disallowed types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'exclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' != '.metaproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.shproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vcxitems'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vdproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '' " />
    </ItemGroup>
    <!-- No filtering -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' != 'exclusionlist' AND '$(RestoreProjectFilterMode)' != 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_FilteredRestoreGraphProjectInputItemsTmp)">
      <Output TaskParameter="Filtered" ItemName="FilteredRestoreGraphProjectInputItemsWithoutDuplicates" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Warn for projects that do not support restore. -->
    <WarnForInvalidProjectsTask Condition=" '$(DisableWarnForInvalidRestoreProjects)' != 'true' AND '$(HideWarningsAndErrors)' != 'true' " AllProjects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" ValidProjects="@(FilteredRestoreGraphProjectInputItems)" />
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraph
    Entry point for creating the project to project restore graph.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraph" DependsOnTargets="_FilterRestoreGraphProjectInputItems;_GetAllRestoreProjectPathItems" Returns="@(_RestoreGraphEntry)">
    <Message Text="Generating dg file" Importance="low" />
    <Message Text="%(_RestoreProjectPathItems.Identity)" Importance="low" />
    <!-- Use all projects if RestoreRecursive is true. Otherwise use only the top level projects. -->
    <ItemGroup>
      <_GenerateRestoreGraphProjectEntryInput Include="@(FilteredRestoreGraphProjectInputItems)" Condition=" '$(RestoreRecursive)' != 'true' " />
      <_GenerateRestoreGraphProjectEntryInput Include="@(_RestoreProjectPathItems)" Condition=" '$(RestoreRecursive)' == 'true' " />
    </ItemGroup>
    <!-- Add top level entries to the direct restore list. These projects will also restore tools. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_GenerateRestoreGraphProjectEntryInput)" Targets="_GenerateRestoreGraphProjectEntry" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
    <!-- Generate a spec for every project including dependencies. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItems)" Targets="_GenerateProjectRestoreGraph" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraphProjectEntry
    Top level entry point within a project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraphProjectEntry" DependsOnTargets="_GenerateRestoreSpecs;_GenerateDotnetCliToolReferenceSpecs" Returns="@(_RestoreGraphEntry)">
    <!-- Returns restore graph entries for the project and all dependencies -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreSpecs
    Mark entry points for restore.
    ============================================================
  -->
  <Target Name="_GenerateRestoreSpecs" DependsOnTargets="_GetRestoreProjectStyle" Returns="@(_RestoreGraphEntry)">
    <Message Text="Restore entry point $(MSBuildProjectFullPath)" Importance="low" />
    <!-- Mark entry point -->
    <ItemGroup Condition=" '$(RestoreProjects)' == '' OR '$(RestoreProjects)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())" Condition=" '$(RestoreProjectStyle)' != 'Unknown' ">
        <Type>RestoreSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateDotnetCliToolReferenceSpecs
    Collect DotnetCliToolReferences
    ============================================================
  -->
  <Target Name="_GenerateDotnetCliToolReferenceSpecs" DependsOnTargets="_GetRestoreSettings" Returns="@(_RestoreGraphEntry)">
    <PropertyGroup>
      <DotnetCliToolTargetFramework Condition=" '$(DotnetCliToolTargetFramework)' == '' ">netcoreapp1.0</DotnetCliToolTargetFramework>
    </PropertyGroup>
    <!-- Write out tool references -->
    <GetRestoreDotnetCliToolsTask Condition=" '$(RestoreDotnetCliToolReferences)' == '' OR '$(RestoreDotnetCliToolReferences)' == 'true' " ProjectPath="$(MSBuildProjectFullPath)" ToolFramework="$(DotnetCliToolTargetFramework)" RestorePackagesPath="$(_OutputPackagesPath)" RestoreFallbackFolders="$(_OutputFallbackFolders)" RestoreSources="$(_OutputSources)" RestoreConfigFilePaths="$(_OutputConfigFilePaths)" DotnetCliToolReferences="@(DotnetCliToolReference)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreDotnetCliToolsTask>
  </Target>
  <!--
    ============================================================
    _GetProjectJsonPath
    Discover the project.json path if one exists for the project.
    ============================================================
  -->
  <Target Name="_GetProjectJsonPath" Returns="$(_CurrentProjectJsonPath)">
    <!-- Get project.json path -->
    <!-- Skip this if the project style is already set. -->
    <GetRestoreProjectJsonPathTask ProjectPath="$(MSBuildProjectFullPath)" Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == '' ">
      <Output TaskParameter="ProjectJsonPath" PropertyName="_CurrentProjectJsonPath" />
    </GetRestoreProjectJsonPathTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreProjectStyle
    Determine the project restore type.
    ============================================================
  -->
  <Target Name="_GetRestoreProjectStyle" DependsOnTargets="_GetProjectJsonPath;CollectPackageReferences" Returns="$(RestoreProjectStyle);$(PackageReferenceCompatibleProjectStyle)">
    <!--
      Older versions of MSBuild do not support the Count() item function which is an optimization.  Expanding the
      entire item list into a semicolon delimited string is slower but older versions of MSBuild don't support it so
      use the older logic if necessary
    -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &lt; '15.0'">
      <_HasPackageReferenceItems Condition="'@(PackageReference)' != ''">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &gt;= '15.0'">
      <_HasPackageReferenceItems Condition="@(PackageReference-&gt;Count()) &gt; 0">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <GetRestoreProjectStyleTask HasPackageReferenceItems="$(_HasPackageReferenceItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" MSBuildProjectName="$(MSBuildProjectName)" ProjectJsonPath="$(_CurrentProjectJsonPath)" RestoreProjectStyle="$(RestoreProjectStyle)">
      <Output TaskParameter="ProjectStyle" PropertyName="RestoreProjectStyle" />
      <Output TaskParameter="IsPackageReferenceCompatibleProjectStyle" PropertyName="PackageReferenceCompatibleProjectStyle" />
    </GetRestoreProjectStyleTask>
    <PropertyGroup>
      <_HasPackageReferenceItems />
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    EnableIntermediateOutputPathMismatchWarning
    If using PackageReference, enable an MSBuild warning if BaseIntermediateOutputPath is set to something different
    than MSBuildProjectExtensionsPath, because it may be unexpected that the assets and related files wouldn't be written
    to the BaseIntermediateOutputPath.
    ============================================================
  -->
  <Target Name="EnableIntermediateOutputPathMismatchWarning" DependsOnTargets="_GetRestoreProjectStyle" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(RestoreProjectStyle)' == 'PackageReference'">
    <PropertyGroup Condition="'$(EnableBaseIntermediateOutputPathMismatchWarning)' == ''">
      <EnableBaseIntermediateOutputPathMismatchWarning>true</EnableBaseIntermediateOutputPathMismatchWarning>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksOutput
    Read target frameworks from the project.
    Non-NETCore project frameworks will be returned.
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksOutput" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworksOutputFiltered)">
    <PropertyGroup>
      <_RestoreProjectFramework />
      <_TargetFrameworkToBeUsed Condition=" '$(_TargetFrameworkOverride)' == '' ">$(TargetFrameworks)</_TargetFrameworkToBeUsed>
    </PropertyGroup>
    <!-- For project.json projects target frameworks will be read from project.json. -->
    <GetProjectTargetFrameworksTask Condition=" '$(RestoreProjectStyle)' != 'ProjectJson'" ProjectPath="$(MSBuildProjectFullPath)" TargetFrameworks="$(_TargetFrameworkToBeUsed)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output TaskParameter="ProjectTargetFrameworks" PropertyName="_RestoreProjectFramework" />
    </GetProjectTargetFrameworksTask>
    <ItemGroup Condition=" '$(_RestoreProjectFramework)' != '' ">
      <_RestoreTargetFrameworksOutputFiltered Include="$(_RestoreProjectFramework.Split(';'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksAsItems
    Read $(TargetFrameworks) from the project as items.
    Projects that do not have $(TargetFrameworks) will noop.
    If $(TargetFramework) is specified globally, it'll be preferred over $(TargetFrameworks)
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksAsItems" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworkItems)">
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' == '' ">
      <_RestoreTargetFrameworkItems Include="$(TargetFrameworks.Split(';'))" />
    </ItemGroup>
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' != '' ">
      <_RestoreTargetFrameworkItems Include="$(_TargetFrameworkOverride)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettings
    ============================================================
  -->
  <Target Name="_GetRestoreSettings" Condition=" '$(RestoreProjectStyle)' == 'PackageReference' OR '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == 'DotnetToolReference' OR '$(RestoreProjectStyle)' == 'PackagesConfig'" DependsOnTargets="_GetRestoreSettingsOverrides;_GetRestoreSettingsCurrentProject;_GetRestoreSettingsAllFrameworks" Returns="$(_OutputSources);$(_OutputPackagesPath);$(_OutputRepositoryPath);$(_OutputFallbackFolders);$(_OutputConfigFilePaths)">
    <PropertyGroup Condition=" '$(RestoreSolutionDirectory)' == '' AND '$(RestoreProjectStyle)' == 'PackagesConfig' AND '$(SolutionDir)' != '*Undefined*'">
      <RestoreSolutionDirectory>$(SolutionDir)</RestoreSolutionDirectory>
    </PropertyGroup>
    <!-- For transitive project styles, we rely on evaluating all the settings and including them in the dg spec to faciliate no-op restore-->
    <GetRestoreSettingsTask ProjectUniqueName="$(MSBuildProjectFullPath)" RestoreSources="$(RestoreSources)" RestorePackagesPath="$(RestorePackagesPath)" RestoreRepositoryPath="$(RestoreRepositoryPath)" RestoreFallbackFolders="$(RestoreFallbackFolders)" RestoreConfigFile="$(RestoreConfigFile)" RestoreRootConfigDirectory="$(RestoreRootConfigDirectory)" RestoreSolutionDirectory="$(RestoreSolutionDirectory)" RestoreSettingsPerFramework="@(_RestoreSettingsPerFramework)" RestorePackagesPathOverride="$(_RestorePackagesPathOverride)" RestoreRepositoryPathOverride="$(_RestoreRepositoryPathOverride)" RestoreSourcesOverride="$(_RestoreSourcesOverride)" RestoreFallbackFoldersOverride="$(_RestoreFallbackFoldersOverride)" RestoreProjectStyle="$(RestoreProjectStyle)" MSBuildStartupDirectory="$(MSBuildStartupDirectory)">
      <Output TaskParameter="OutputSources" PropertyName="_OutputSources" />
      <Output TaskParameter="OutputPackagesPath" PropertyName="_OutputPackagesPath" />
      <Output TaskParameter="OutputRepositoryPath" PropertyName="_OutputRepositoryPath" />
      <Output TaskParameter="OutputFallbackFolders" PropertyName="_OutputFallbackFolders" />
      <Output TaskParameter="OutputConfigFilePaths" PropertyName="_OutputConfigFilePaths" />
    </GetRestoreSettingsTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsCurrentProject
    Generate items for a single framework.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsCurrentProject" Condition=" '$(TargetFrameworks)' == '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)" />
  <!--
    ============================================================
    _GetRestoreSettingsAllFrameworks
    Generate items for all frameworks.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems;_GetRestoreProjectStyle" Returns="@(_RestoreSettingsPerFramework)">
    <!-- Read additional sources and fallback folders for each framework  -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GetRestoreSettingsPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreSettingsPerFramework" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsPerFramework
    Generate items with framework specific settings.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)">
    <ItemGroup>
      <_RestoreSettingsPerFramework Include="$([System.Guid]::NewGuid())">
        <RestoreAdditionalProjectSources>$(RestoreAdditionalProjectSources)</RestoreAdditionalProjectSources>
        <RestoreAdditionalProjectFallbackFolders>$(RestoreAdditionalProjectFallbackFolders)</RestoreAdditionalProjectFallbackFolders>
        <RestoreAdditionalProjectFallbackFoldersExcludes>$(RestoreAdditionalProjectFallbackFoldersExcludes)</RestoreAdditionalProjectFallbackFoldersExcludes>
      </_RestoreSettingsPerFramework>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectSpec
    Generate a restore project spec for the current project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectSpec" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworksOutput;_GetRestoreSettings" Returns="@(_RestoreGraphEntry)">
    <!-- Determine the restore output path -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <RestoreOutputPath Condition=" '$(RestoreOutputPath)' == '' ">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)" Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson'">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <!--
      Determine project name for the assets file.
      Highest priority: PackageId
      If PackageId does not exist use: AssemblyName
      If AssemblyName does not exist fallback to the project file name without the extension: $(MSBuildProjectName)

      For non-PackageReference projects use only: $(MSBuildProjectName)
    -->
    <PropertyGroup>
      <_RestoreProjectName>$(MSBuildProjectName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(AssemblyName)' != '' ">$(AssemblyName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(PackageId)' != '' ">$(PackageId)</_RestoreProjectName>
    </PropertyGroup>
    <!--
      Determine project version for .NETCore projects
      Default to 1.0.0
      Use Version if it exists
      Override with PackageVersion if it exists (same as pack)
    -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreProjectVersion>1.0.0</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(Version)' != '' ">$(Version)</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(PackageVersion)' != '' ">$(PackageVersion)</_RestoreProjectVersion>
    </PropertyGroup>
    <!-- Determine if this will use cross targeting -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(TargetFrameworks)' != '' ">
      <_RestoreCrossTargeting>true</_RestoreCrossTargeting>
    </PropertyGroup>
    <!-- Determine if ContentFiles should be written by NuGet -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_RestoreSkipContentFileWrite)' == '' ">
      <_RestoreSkipContentFileWrite Condition=" '$(TargetFrameworks)' == '' AND '$(TargetFramework)' == '' ">true</_RestoreSkipContentFileWrite>
    </PropertyGroup>
    <!-- Write properties for the top level entry point -->
    <ItemGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <Version>$(_RestoreProjectVersion)</Version>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <RuntimeIdentifiers>$(RuntimeIdentifiers);$(RuntimeIdentifier)</RuntimeIdentifiers>
        <RuntimeSupports>$(RuntimeSupports)</RuntimeSupports>
        <CrossTargeting>$(_RestoreCrossTargeting)</CrossTargeting>
        <RestoreLegacyPackagesDirectory>$(RestoreLegacyPackagesDirectory)</RestoreLegacyPackagesDirectory>
        <ValidateRuntimeAssets>$(ValidateRuntimeIdentifierCompatibility)</ValidateRuntimeAssets>
        <SkipContentFileWrite>$(_RestoreSkipContentFileWrite)</SkipContentFileWrite>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <WarningsAsErrors>$(WarningsAsErrors)</WarningsAsErrors>
        <WarningsNotAsErrors>$(WarningsNotAsErrors)</WarningsNotAsErrors>
        <NoWarn>$(NoWarn)</NoWarn>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <_CentralPackageVersionsEnabled>$(_CentralPackageVersionsEnabled)</_CentralPackageVersionsEnabled>
        <CentralPackageFloatingVersionsEnabled>$(CentralPackageFloatingVersionsEnabled)</CentralPackageFloatingVersionsEnabled>
        <CentralPackageVersionOverrideEnabled>$(CentralPackageVersionOverrideEnabled)</CentralPackageVersionOverrideEnabled>
        <CentralPackageTransitivePinningEnabled>$(CentralPackageTransitivePinningEnabled)</CentralPackageTransitivePinningEnabled>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
        <NuGetAuditMode>$(NuGetAuditMode)</NuGetAuditMode>
        <SdkAnalysisLevel>$(SdkAnalysisLevel)</SdkAnalysisLevel>
        <UsingMicrosoftNETSdk>$(UsingMicrosoftNETSdk)</UsingMicrosoftNETSdk>
        <RestoreUseLegacyDependencyResolver>$(RestoreUseLegacyDependencyResolver)</RestoreUseLegacyDependencyResolver>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use project.json -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectJsonPath>$(_CurrentProjectJsonPath)</ProjectJsonPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use packages.config -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'PackagesConfig' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config')">$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config</PackagesConfigPath>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.config')">$(MSBuildProjectDirectory)\packages.config</PackagesConfigPath>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <Sources>$(_OutputSources)</Sources>
        <SolutionDir>$(SolutionDir)</SolutionDir>
        <RepositoryPath>$(_OutputRepositoryPath)</RepositoryPath>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Non-NuGet type -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'Unknown' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraph
    Recursively walk project to project references.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraph" DependsOnTargets="&#xD;&#xA;      _GetRestoreProjectStyle;&#xD;&#xA;      _GenerateRestoreProjectSpec;&#xD;&#xA;      _GenerateRestoreDependencies" Returns="@(_RestoreGraphEntry)">
    <!-- Output from dependency targets -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreDependencies
    Generate items for package and project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreDependencies" DependsOnTargets="_GenerateProjectRestoreGraphAllFrameworks;_GenerateProjectRestoreGraphCurrentProject" Returns="@(_RestoreGraphEntry)" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphAllFrameworks
    Walk dependencies for all frameworks.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreGraphEntry)">
    <!-- Get project and package references  -->
    <!-- Evaluate for each framework -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateProjectRestoreGraphPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraphCurrentProject
    Walk dependencies with the current framework.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateProjectRestoreGraphPerFramework" Returns="@(_RestoreGraphEntry)" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphPerFramework
    Walk dependencies using $(TargetFramework)
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphPerFramework" DependsOnTargets="_GetRestoreProjectStyle;_CollectRestoreInputs" Returns="@(_RestoreGraphEntry)">
    <!-- Write out project references -->
    <GetRestoreProjectReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" ProjectReferences="@(ProjectReference)" TargetFrameworks="$(TargetFramework)" ParentProjectPath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreProjectReferencesTask>
    <!-- Write out package references-->
    <GetRestorePackageReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageReferences="@(PackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageReferencesTask>
    <!-- Write out central package versions -->
    <GetCentralPackageVersionsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_CentralPackageVersionsEnabled)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" CentralPackageVersions="@(PackageVersion)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetCentralPackageVersionsTask>
    <!-- Write out package downloads -->
    <GetRestorePackageDownloadsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageDownloads="@(PackageDownload)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageDownloadsTask>
    <!-- Write out Framework References-->
    <GetRestoreFrameworkReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" FrameworkReferences="@(FrameworkReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreFrameworkReferencesTask>
    <!-- Write out advisory suppressions-->
    <GetRestoreNuGetAuditSuppressionsTask ProjectUniqueName="$(MSBuildProjectFullPath)" NuGetAuditSuppressions="@(NuGetAuditSuppress)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreNuGetAuditSuppressionsTask>
    <!-- Write out pruned package references-->
    <GetRestorePrunePackageReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" PrunePackageReferences="@(PrunePackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePrunePackageReferencesTask>
    <!-- Write out target framework information -->
    <ItemGroup Condition="  '$(PackageReferenceCompatibleProjectStyle)' == 'true'">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>TargetFrameworkInformation</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <PackageTargetFallback>$(PackageTargetFallback)</PackageTargetFallback>
        <AssetTargetFallback>$(AssetTargetFallback)</AssetTargetFallback>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
        <TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
        <TargetFrameworkProfile>$(TargetFrameworkProfile)</TargetFrameworkProfile>
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <CLRSupport>$(CLRSupport)</CLRSupport>
        <RuntimeIdentifierGraphPath>$(RuntimeIdentifierGraphPath)</RuntimeIdentifierGraphPath>
        <WindowsTargetPlatformMinVersion>$(WindowsTargetPlatformMinVersion)</WindowsTargetPlatformMinVersion>
        <RestoreEnablePackagePruning>$(RestoreEnablePackagePruning)</RestoreEnablePackagePruning>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsCurrentProject
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)" />
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsPerFramework
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)">
    <!-- Get the absolute paths to all projects -->
    <ConvertToAbsolutePath Paths="@(ProjectReference)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_RestoreGraphAbsoluteProjectPaths" />
    </ConvertToAbsolutePath>
    <ItemGroup>
      <_RestoreProjectPathItems Include="$(_RestoreGraphAbsoluteProjectPaths)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItems
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItems" DependsOnTargets="_GenerateRestoreProjectPathItemsAllFrameworks;_GenerateRestoreProjectPathItemsCurrentProject" Returns="@(_CurrentRestoreProjectPathItems)">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItems)">
      <Output TaskParameter="Filtered" ItemName="_CurrentRestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsAllFrameworks
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreProjectPathItems)">
    <!-- Get all project references for the current project  -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" ContinueOnError="$(RestoreContinueOnError)" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathWalk
    Recursively walk projects
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathWalk" DependsOnTargets="_GenerateRestoreProjectPathItems" Returns="@(_RestoreProjectPathItems)">
    <!-- Walk project references  -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Include the current project in the result -->
    <ItemGroup>
      <_GenerateRestoreProjectPathWalkOutputs Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_GenerateRestoreProjectPathWalkOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GetAllRestoreProjectPathItems
    Get the full list of known projects.
    This includes all child projects from all target frameworks.
    ============================================================
  -->
  <Target Name="_GetAllRestoreProjectPathItems" DependsOnTargets="_FilterRestoreGraphProjectInputItems" Returns="@(_RestoreProjectPathItems)">
    <NuGetMessageTask Name="DeterminingProjectsToRestore" Importance="High" />
    <!-- Walk projects -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItemsOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItemsWithoutDupes" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsOverrides
    Get global property overrides that should be resolved
    against the current working directory instead of the project.
    This is done by calling into NuGet.targets in a new scope,
    project properties will not be returned by the calls below.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsOverrides" Returns="$(_RestorePackagesPathOverride);$(_RestoreRepositoryPathOverride);$(_RestoreSourcesOverride);$(_RestoreFallbackFoldersOverride)">
    <!-- RestorePackagesPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestorePackagesPath)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestorePackagesPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestorePackagesPathOverride" />
    </MSBuild>
    <!-- RestoreRepositoryPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreRepositoryPathOverride)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreRepositoryPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreRepositoryPathOverride" />
    </MSBuild>
    <!-- RestoreSourcesOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreSources)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreSourcesOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreSourcesOverride" />
    </MSBuild>
    <!-- RestoreFallbackFoldersOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreFallbackFolders)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreFallbackFoldersOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreFallbackFoldersOverride" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestorePackagesPathOverride
    ============================================================
  -->
  <Target Name="_GetRestorePackagesPathOverride" Returns="$(_RestorePackagesPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestorePackagesPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreRepositoryPathOverride
    ============================================================
  -->
  <Target Name="_GetRestoreRepositoryPathOverride" Returns="$(_RestoreRepositoryPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestoreRepositoryPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSourcesOverride
    ============================================================
  -->
  <Target Name="_GetRestoreSourcesOverride" Returns="$(_RestoreSourcesOverride)">
    <PropertyGroup>
      <_RestoreSourcesOverride>$(RestoreSources)</_RestoreSourcesOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreFallbackFoldersOverride
    ============================================================
  -->
  <Target Name="_GetRestoreFallbackFoldersOverride" Returns="$(_RestoreFallbackFoldersOverride)">
    <PropertyGroup>
      <_RestoreFallbackFoldersOverride>$(RestoreFallbackFolders)</_RestoreFallbackFoldersOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworkOverride
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworkOverride" Condition=" '$(_DisableNuGetRestoreTargetFrameworksOverride)' != 'true' " Returns="$(_TargetFrameworkOverride)">
    <GetGlobalPropertyValueTask PropertyName="TargetFramework" Condition=" '$(TargetFrameworks)' != '' ">
      <Output TaskParameter="GlobalPropertyValue" PropertyName="_TargetFrameworkOverride" />
    </GetGlobalPropertyValueTask>
    <!-- Only set the override if TargetFrameworks has not been overriden as well. In that case, prefer it. -->
  </Target>
  <!--
    ============================================================
    _GetTargetFrameworkOverrides
    ============================================================
  -->
  <Target Name="_GetTargetFrameworkOverrides" Returns="$(_TargetFrameworkOverride)">
    <PropertyGroup>
      <_TargetFrameworkOverride Condition=" '$(TargetFrameworks)' == '' ">$(TargetFramework)</_TargetFrameworkOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _IsProjectRestoreSupported
    Verify restore targets exist in the project.
    ============================================================
  -->
  <Target Name="_IsProjectRestoreSupported" Returns="@(_ValidProjectsForRestore)">
    <ItemGroup>
      <_ValidProjectsForRestore Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Import NuGet.RestoreEx.targets if the MSBuild property 'RestoreEnableStaticGraph'
    is 'true'.  This file overrides the Restore target to use MSBuild Static Graph
    to load and evaluate projects which is much faster.

    This feature is not supported for NuGet.exe scenarios and NuGet.RestoreEx.targets
    won't exist in that case.
    ============================================================
  -->
  <!--<Import Project="NuGet.RestoreEx.targets" Condition="'$(RestoreUseStaticGraphEvaluation)' == 'true' And Exists('NuGet.RestoreEx.targets')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonTargets)" Condition="'$(CustomAfterMicrosoftCommonTargets)' != '' and Exists('$(CustomAfterMicrosoftCommonTargets)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <MicrosoftNETBuildExtensionsTargets Condition="'$(MicrosoftNETBuildExtensionsTargets)' == ''">$(MSBuildExtensionsPath)\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets</MicrosoftNETBuildExtensionsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MicrosoftNETBuildExtensionsTargets)" Condition="Exists('$(MicrosoftNETBuildExtensionsTargets)')">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_TargetFrameworkVersionWithoutV>$(TargetFrameworkVersion.TrimStart('vV'))</_TargetFrameworkVersionWithoutV>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == '' AND '$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)\tools\net9.0\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == ''">$(MSBuildThisFileDirectory)\tools\net472\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <!-- Include conflict resolution targets for NETFramework and allow other frameworks to opt-in -->
    <ResolveAssemblyConflicts Condition="'$(ResolveAssemblyConflicts)' == '' AND '$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ResolveAssemblyConflicts>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Build.Extensions.NETFramework.targets" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.NETFramework.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.NETFramework.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Add NETStandard references if targetframeworkversion supports netstandard2.0 (net461 or later) -->
    <ImplicitlyExpandNETStandardFacades Condition="'$(ImplicitlyExpandNETStandardFacades)' == '' AND '$(_TargetFrameworkVersionWithoutV)' &gt;= '4.6.1'">true</ImplicitlyExpandNETStandardFacades>
  </PropertyGroup>
  <UsingTask TaskName="GetDependsOnNETStandard" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <UsingTask TaskName="NETBuildExtensionsError" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <UsingTask TaskName="NETBuildExtensionsWarning" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <UsingTask TaskName="AddFacadesToReferences" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <Target Name="ImplicitlyExpandNETStandardFacades" Condition="'$(ImplicitlyExpandNETStandardFacades)' == 'true'" BeforeTargets="_HandlePackageFileConflicts;ResolveAssemblyReferences">
    <ItemGroup>
      <_CandidateNETStandardReferences Include="@(Reference);@(_ResolvedProjectReferencePaths)" />
      <_InboxNETStandardFolders Include="$(TargetFrameworkDirectory)" />
    </ItemGroup>
    <!-- determine if NETStandard.dll is supported inbox for this TargetFramework -->
    <PropertyGroup Condition="'$(NETStandardInbox)' == ''">
      <NETStandardInbox Condition="Exists('%(_InboxNETStandardFolders.Identity)\netstandard.dll')">true</NETStandardInbox>
    </PropertyGroup>
    <!-- determine if any references depend on NETStandard -->
    <!-- Check metadata of _ResolvedProjectReferencePaths items.  This handles the case where we are doing a design-time build and a referenced project
         hasn't been built yet, so there is no corresponding assembly on disk for the GetDependsOnNETStandard task to examine.

         More context: https://github.com/dotnet/sdk/issues/1403
         -->
    <PropertyGroup Condition="'$(DependsOnNETStandard)' == '' AND '$(NETStandardInbox)' != 'true'">
      <DependsOnNETStandard Condition="('%(_ResolvedProjectReferencePaths.TargetFrameworkIdentifier)' == '.NETStandard') And ('%(_ResolvedProjectReferencePaths.TargetFrameworkVersion)' &gt;= '1.5')">true</DependsOnNETStandard>
    </PropertyGroup>
    <PropertyGroup Condition="'@(_CandidateNETStandardReferences)' != ''">
      <!-- Use an intermediate property to simplify condition.  Run GetDependsOnNETStandard if either: -->
      <!-- 1. The .NET Standard 2.0 support need to be injected -->
      <_RunGetDependsOnNETStandard Condition="'$(DependsOnNETStandard)' == '' AND '$(NETStandardInbox)' != 'true'">true</_RunGetDependsOnNETStandard>
      <!-- 2. The target framework is .NET 4.7.1, which needs to special case some shims -->
      <_RunGetDependsOnNETStandard Condition="'$(DependsOnNETStandard)' == '' AND '$(_TargetFrameworkVersionWithoutV)' == '4.7.1'">true</_RunGetDependsOnNETStandard>
    </PropertyGroup>
    <GetDependsOnNETStandard Condition="'$(_RunGetDependsOnNETStandard)' == 'true'" References="@(_CandidateNETStandardReferences)">
      <Output TaskParameter="DependsOnNETStandard" PropertyName="DependsOnNETStandard" />
    </GetDependsOnNETStandard>
    <!-- prevent using an older SDK version with NETStandard2.0 references -->
    <PropertyGroup>
      <_UsingOldSDK Condition="'$(UsingMicrosoftNETSdk)' != 'true' AND ('$(TargetFramework)' != '' OR '$(TargetFrameworks)' != '')">true</_UsingOldSDK>
    </PropertyGroup>
    <NETBuildExtensionsError Condition="'$(DependsOnNETStandard)' == 'true' AND '$(NETStandardInbox)' != 'true' AND '$(_UsingOldSDK)' == 'true'" ResourceName="UnsupportedSDKVersionForNetStandard20" />
    <!--
      .NET 4.7.1 has support for .NET Standard 2.0 built-in, so most of the facades aren't necessary.  However, the assembly versions of a few set of assemblies
      do not yet match the ones shipped in the support package for .NET Standard 2.0 on .NET 4.7 and below. This means that .NET 4.7 or lower libraries might have
      references to higher versions of these assemblies than are available in-box in .NET 4.7, leading to assembly loading errors. So if there is a dependency on
      netstandard.dll, we include DLLs for .NET 4.7.1 from the support package to avoid these errors.
      -->
    <ItemGroup Condition="'$(_TargetFrameworkVersionWithoutV)' == '4.7.1'">
      <_NETStandardLibraryNETFrameworkLib Include="$(MSBuildThisFileDirectory)\net471\lib\*.dll" Condition="'$(DependsOnNETStandard)' == 'true'" />
    </ItemGroup>
    <!-- if any reference depends on netstandard and it is not inbox, add references and implementation assemblies for netstandard2.0  -->
    <ItemGroup Condition="'$(DependsOnNETStandard)' == 'true' AND '$(NETStandardInbox)' != 'true' AND '$(_TargetFrameworkVersionWithoutV)' &lt; '4.7.1'">
      <_NETStandardLibraryNETFrameworkLib Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '4.7'" Include="$(MSBuildThisFileDirectory)net47\lib\*.dll" />
      <_NETStandardLibraryNETFrameworkLib Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '4.6.2'" Include="$(MSBuildThisFileDirectory)net462\lib\*.dll" Exclude="@(_NETStandardLibraryNETFrameworkLib->'$(MSBuildThisFileDirectory)net462\lib\%(FileName).dll')" />
      <_NETStandardLibraryNETFrameworkLib Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '4.6.1'" Include="$(MSBuildThisFileDirectory)net461\lib\*.dll" Exclude="@(_NETStandardLibraryNETFrameworkLib->'$(MSBuildThisFileDirectory)net461\lib\%(FileName).dll')" />
    </ItemGroup>
    <ItemGroup Condition="'@(_NETStandardLibraryNETFrameworkLib)' != ''">
      <!-- Put each facade assembly in two separate items: Reference with Private set to false, which means it won't be
           copied locally, and ReferenceCopyLocalPaths, which will be copied locally.  The reason for this split is to
           workaround https://github.com/dotnet/core-setup/issues/2981 by ensuring that the facades are written
           to the deps.json with a type of "referenceassembly" instead of "reference".

           The exception is netfx.force.conflicts.dll, which shouldn't be copied local.  So it isn't included in
           ReferenceCopyLocalPaths.

           When we add the Reference items, we use the simple name as the ItemSpec, and refer to the full path
           to the DLL via the HintPath metadata.  This is so that if we're replacing a simple Reference,
           the OriginalItemSpec of the resolved reference will match to the Reference that was replaced,
           and VS won't show a warning icon on the reference.  See https://github.com/dotnet/sdk/issues/1499
           -->
      <ReferenceCopyLocalPaths Include="@(_NETStandardLibraryNETFrameworkLib)" Condition="'%(FileName)' != 'netfx.force.conflicts'" />
      <_UpdatedReference Remove="@(_UpdatedReference)" />
    </ItemGroup>
    <!-- Facade assemblies should override simple name references.  However, we want to preserve custom metadata
         on those simple name references (for example for aliases).  That's what this task does. -->
    <AddFacadesToReferences References="@(Reference)" Facades="@(_NETStandardLibraryNETFrameworkLib)" Condition="'@(_NETStandardLibraryNETFrameworkLib)' != ''">
      <Output TaskParameter="UpdatedReferences" ItemName="_UpdatedReference" />
    </AddFacadesToReferences>
    <ItemGroup Condition="'@(_NETStandardLibraryNETFrameworkLib)' != ''">
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_UpdatedReference)" />
      <_UpdatedReference Remove="@(_UpdatedReference)" />
    </ItemGroup>
  </Target>
  <!-- There was issue in .NET 4.7.1 where System.IO.Compression.ZipFile was not correctly in the unification table.
       A workaround to issues that caused was to add a binding redirect for the assembly from version 4.0.3.0 down to
       4.0.0.0.  However, with the fix to dotnet/sdk#2221, ResolveAssemblyReference now sees a conflicting version for
       the assembly, and suggests a redirect to 4.0.3.0.  With automatic binding redirection, this overrides the redirect
       to 4.0.0.0, which causes a runtime failure.

       So here we disable any suggested binding redirect for System.IO.Compression.ZipFile.  Assemblies in the unification
       table generally should not need binding redirects, so it should be OK to do this for 4.7.2 and forward, and on 4.7.1
       the assembly isn't in the unification table so this allows the original workaround redirect to be preserved. -->
  <Target Name="_RemoveZipFileSuggestedRedirect" BeforeTargets="GenerateBindingRedirects" DependsOnTargets="ResolveAssemblyReferences" Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '4.7.1' And '$(AllowZipFileRedirect)' != 'true'">
    <ItemGroup>
      <SuggestedBindingRedirects Remove="System.IO.Compression.ZipFile, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!-- Only import ConflictResolution targets for non-SDK projects, SDK projects have ConflictResolution built in -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Build.Extensions.ConflictResolution.targets" Condition="'$(ResolveAssemblyConflicts)' == 'true' AND '$(UsingMicrosoftNETSdk)' != 'true'">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.ConflictResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.ConflictResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DisableHandlePackageFileConflicts)' != 'true'">
    <!-- Non-SDK using project.json or PackageReference, run after references are read from the lock/assets file -->
    <_HandlePackageFileConflictsAfter>ResolveNuGetPackageAssets</_HandlePackageFileConflictsAfter>
    <!-- In case ResolveNuGetPackageAssets is not run (eg: packages.config), ensure we run before targets that consume references -->
    <_HandlePackageFileConflictsBefore>ResolveAssemblyReferences</_HandlePackageFileConflictsBefore>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.DefaultPackageConflictOverrides.targets">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.DefaultPackageConflictOverrides.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultPackageConflictOverrides.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition="'$(DisableDefaultPackageConflictOverrides)' != 'true'">
    <PackageConflictOverrides Include="Microsoft.NETCore.App" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')">
      <OverriddenPackages>
        Microsoft.CSharp|4.4.0;
        Microsoft.Win32.Primitives|4.3.0;
        Microsoft.Win32.Registry|4.4.0;
        runtime.debian.8-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.23-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.24-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.13.2-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.42.1-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.Apple|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.rhel.7-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.14.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        System.AppContext|4.3.0;
        System.Buffers|4.4.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.DiagnosticSource|4.4.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.AccessControl|4.4.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Metadata|1.5.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Cng|4.4.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.OpenSsl|4.4.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
    <PackageConflictOverrides Include="NETStandard.Library">
      <OverriddenPackages>
        Microsoft.Win32.Primitives|4.3.0;
        System.AppContext|4.3.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.ConflictResolution.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ResolvePackageFileConflicts" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <Target Name="_HandlePackageFileConflicts" BeforeTargets="$(_HandlePackageFileConflictsBefore)" AfterTargets="$(_HandlePackageFileConflictsAfter)" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Condition="'@(Reference)' != '' Or '@(ReferenceCopyLocalPaths)' != ''">
    <ResolvePackageFileConflicts References="@(Reference)" ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PackageOverrides="@(PackageConflictOverrides)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferencesWithoutConflicts" ItemName="_ReferencesWithoutConflicts" />
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReferenceCopyLocalPathsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_ConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <!-- Replace Reference / ReferenceCopyLocalPaths with the filtered lists.
         We must remove all and include rather than just remove since removal is based
         only on ItemSpec and duplicate ItemSpecs may exist with different metadata
         (eg: HintPath) -->
    <ItemGroup>
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_ReferencesWithoutConflicts)" />
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
      <ReferenceCopyLocalPaths Include="@(_ReferenceCopyLocalPathsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.targets\ImportAfter\Microsoft.TestPlatform.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.TestPlatform.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Microsoft.TestPlatform.targets for VSTest target -->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <VSTestTargets Condition="'$(VSTestTargets)'==''">$(MSBuildExtensionsPath)\Microsoft.TestPlatform.targets</VSTestTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VSTestTargets)" Condition="Exists('$(VSTestTargets)')">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.TestPlatform.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.TestPlatform.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <!-- Load Microsoft.TestPlatform.Build.Tasks.dll, this can be overridden to use a different version with $(VSTestTaskAssemblyFile) -->
  <PropertyGroup>
    <VSTestTaskAssemblyFile Condition="$(VSTestTaskAssemblyFile) == ''">Microsoft.TestPlatform.Build.dll</VSTestTaskAssemblyFile>
    <VSTestConsolePath Condition="$(VSTestConsolePath) == ''">$([System.IO.Path]::Combine($(MSBuildThisFileDirectory),"vstest.console.dll"))</VSTestConsolePath>
    <VSTestNoBuild Condition="'$(VSTestNoBuild)' == ''">False</VSTestNoBuild>
    <VsTestUseMSBuildOutput Condition="'$(VsTestUseMSBuildOutput)' == ''">False</VsTestUseMSBuildOutput>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestTask" AssemblyFile="$(VSTestTaskAssemblyFile)" />
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestLogsTask" AssemblyFile="$(VSTestTaskAssemblyFile)" />
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestTask2" AssemblyFile="$(VSTestTaskAssemblyFile)" />
  <!--
    ============================================================
    Test target
    Main entry point for running tests through vstest.console.exe
    ============================================================
  -->
  <Target Name="VSTest" DependsOnTargets="ShowInfoMessageIfProjectHasNoIsTestProjectProperty">
    <!-- Unloggable colorized output (cf. https://github.com/microsoft/vstest/issues/680) -->
    <!-- Fallback to this old view when terminal logger is not enabled (_MSBUILDTLENABLED==0) , or when user explicitly opts out (VsTestUseMSBuildOutput != true) -->
    <CallTarget Targets="_VSTestConsole" Condition="$(_MSBUILDTLENABLED) == '0' OR !$(VsTestUseMSBuildOutput) OR $(MSBUILDENSURESTDOUTFORTASKPROCESSES) == '1'" />
    <!-- Proper MSBuild integration, but no custom colorization -->
    <!-- Use the new view whe terminal logger is enabled (_MSBUILDTLENABLED==0), and user did not opt out (VsTestUseMSBuildOutput == true) -->
    <CallTarget Targets="_VSTestMSBuild" Condition="$(_MSBUILDTLENABLED) == '1' AND $(VsTestUseMSBuildOutput)" />
  </Target>
  <!--
    Used when called from dotnet msbuild command line: uses MSBuild logs but does not allow for console colorization.
    We call to empty target _TestRunStart to mark start of the actual test running, in case we need to do build before
    the test running. This is used in MSBuild Terminal Logger to detect that the current project will run some tests.
  -->
  <Target Name="_VSTestMSBuild" Condition="'$(IsTestProject)' == 'true'">
    <CallTarget Condition="!$(VSTestNoBuild)" Targets="BuildProject" />
    <CallTarget Targets="_TestRunStart" />
    <VSTestTask2 TestFileFullPath="$(TargetPath)" VSTestSetting="$([MSBuild]::ValueOrDefault($(VSTestSetting), '$(RunSettingsFilePath)'))" VSTestTestAdapterPath="$(VSTestTestAdapterPath)" VSTestFramework="$(TargetFrameworkMoniker)" VSTestPlatform="$(PlatformTarget)" VSTestTestCaseFilter="$(VSTestTestCaseFilter)" VSTestLogger="$(VSTestLogger)" VSTestListTests="$(VSTestListTests)" VSTestDiag="$(VSTestDiag)" VSTestCLIRunSettings="$(VSTestCLIRunSettings)" VSTestConsolePath="$(VSTestConsolePath)" VSTestResultsDirectory="$(VSTestResultsDirectory)" VSTestVerbosity="$(VSTestVerbosity)" VSTestCollect="$(VSTestCollect)" VSTestBlame="$(VSTestBlame)" VSTestBlameCrash="$(VSTestBlameCrash)" VSTestBlameCrashDumpType="$(VSTestBlameCrashDumpType)" VSTestBlameCrashCollectAlways="$(VSTestBlameCrashCollectAlways)" VSTestBlameHang="$(VSTestBlameHang)" VSTestBlameHangDumpType="$(VSTestBlameHangDumpType)" VSTestBlameHangTimeout="$(VSTestBlameHangTimeout)" VSTestTraceDataCollectorDirectoryPath="$(TraceDataCollectorDirectoryPath)" VSTestArtifactsProcessingMode="$(VSTestArtifactsProcessingMode)" VSTestSessionCorrelationId="$(VSTestSessionCorrelationId)" VSTestNoLogo="$(VSTestNoLogo)" />
  </Target>
  <Target Name="_TestRunStart" />
  <!-- Used when called from dotnet test command line: does not use MSBuild logs to allow for console colorization -->
  <Target Name="_VSTestConsole">
    <CallTarget Condition="'$(VSTestNoBuild)' != 'true' AND '$(IsTestProject)' == 'true'" Targets="BuildProject" />
    <CallTarget Targets="ShowCallOfVSTestTaskWithParameter" />
    <VSTestTask TestFileFullPath="$(TargetPath)" VSTestSetting="$([MSBuild]::ValueOrDefault($(VSTestSetting), '$(RunSettingsFilePath)'))" VSTestTestAdapterPath="$(VSTestTestAdapterPath)" VSTestFramework="$(TargetFrameworkMoniker)" VSTestPlatform="$(PlatformTarget)" VSTestTestCaseFilter="$(VSTestTestCaseFilter)" VSTestLogger="$(VSTestLogger)" VSTestListTests="$(VSTestListTests)" VSTestDiag="$(VSTestDiag)" VSTestCLIRunSettings="$(VSTestCLIRunSettings)" VSTestConsolePath="$(VSTestConsolePath)" VSTestResultsDirectory="$(VSTestResultsDirectory)" VSTestVerbosity="$(VSTestVerbosity)" VSTestCollect="$(VSTestCollect)" VSTestBlame="$(VSTestBlame)" VSTestBlameCrash="$(VSTestBlameCrash)" VSTestBlameCrashDumpType="$(VSTestBlameCrashDumpType)" VSTestBlameCrashCollectAlways="$(VSTestBlameCrashCollectAlways)" VSTestBlameHang="$(VSTestBlameHang)" VSTestBlameHangDumpType="$(VSTestBlameHangDumpType)" VSTestBlameHangTimeout="$(VSTestBlameHangTimeout)" VSTestTraceDataCollectorDirectoryPath="$(TraceDataCollectorDirectoryPath)" VSTestArtifactsProcessingMode="$(VSTestArtifactsProcessingMode)" VSTestSessionCorrelationId="$(VSTestSessionCorrelationId)" VSTestNoLogo="$(VSTestNoLogo)" Condition="'$(IsTestProject)' == 'true'" />
  </Target>
  <Target Name="ShowInfoMessageIfProjectHasNoIsTestProjectProperty" Condition="'$(IsTestProject)' == ''">
    <VSTestLogsTask LogType="NoIsTestProjectProperty" ProjectFilePath="$(MSBuildProjectFullPath)" />
  </Target>
  <Target Name="BuildProject">
    <CallTarget Targets="ShowMsbuildWithParameter" />
    <VSTestLogsTask LogType="BuildStarted" />
    <MSBuild Projects="$(MSBuildProjectFullPath)" />
    <VSTestLogsTask LogType="BuildCompleted" />
    <Message Importance="Low" Text="Done Building project $(MSBuildProjectFullPath) for TargetFramework=$(TargetFramework)" />
  </Target>
  <Target Name="ShowMsbuildWithParameter">
    <Message Importance="Low" Text="Building project $(MSBuildProjectFullPath) for TargetFramework=$(TargetFramework)" />
    <Message Importance="Low" Text="Value passed to msbuild are..." />
    <Message Importance="Low" Text="Configuration = $(Configuration)" />
    <Message Importance="Low" Text="TargetFramework = $(TargetFramework)" />
    <Message Importance="Low" Text="Platform = $(PlatformTarget)" />
    <Message Importance="Low" Text="OutputPath = $(OutputPath)" />
  </Target>
  <Target Name="ShowCallOfVSTestTaskWithParameter">
    <Message Importance="Low" Text="Calling task Microsoft.TestPlatform.Build.Tasks.VSTestTask with following parameter..." />
    <Message Importance="Low" Text="TestFileFullPath = $(TargetPath)" />
    <Message Importance="Low" Text="VSTestSetting = $(VSTestSetting)" />
    <Message Importance="Low" Text="VSTestTestAdapterPath = $(VSTestTestAdapterPath)" />
    <Message Importance="Low" Text="VSTestFramework = $(TargetFrameworkMoniker)" />
    <Message Importance="Low" Text="VSTestPlatform = $(PlatformTarget)" />
    <Message Importance="Low" Text="VSTestTestCaseFilter = $(VSTestTestCaseFilter)" />
    <Message Importance="Low" Text="VSTestLogger = $(VSTestLogger)" />
    <Message Importance="Low" Text="VSTestListTests = $(VSTestListTests)" />
    <Message Importance="Low" Text="VSTestDiag = $(VSTestDiag)" />
    <Message Importance="Low" Text="VSTestCLIRunSettings = $(VSTestCLIRunSettings)" />
    <Message Importance="Low" Text="VSTestResultsDirectory = $(VSTestResultsDirectory)" />
    <Message Importance="Low" Text="VSTestConsolePath = $(VSTestConsolePath)" />
    <Message Importance="Low" Text="VSTestVerbosity = $(VSTestVerbosity)" />
    <Message Importance="Low" Text="VSTestCollect = $(VSTestCollect)" />
    <Message Importance="Low" Text="VSTestBlame = $(VSTestBlame)" />
    <Message Importance="Low" Text="VSTestTraceDataCollectorDirectoryPath = $(TraceDataCollectorDirectoryPath)" />
    <Message Importance="Low" Text="VSTestNoLogo = $(VSTestNoLogo)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Current\Microsoft.Common.targets\ImportAfter\Microsoft.TestPlatform.ImportAfter.targets
============================================================================================================================================
-->
  <!-- Register TestingPlatform task -->
  <UsingTask TaskName="GetTestsProject" AssemblyFile="$(MicrosoftNETBuildTasksDirectory)Microsoft.NET.Build.Tasks.dll" />
  <Target Name="_GetTestsProject" Condition=" $(IsTestProject) == 'true' OR '$(IsTestingPlatformApplication)' == 'true' ">
    <GetTestsProject TargetPath="$(TargetPath)" GetTestsProjectPipeName="$(GetTestsProjectPipeName)" ProjectFullPath="$(MSBuildProjectFullPath)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Common.targets
============================================================================================================================================
-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
          $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.targets

        Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
        management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup xmlns="">
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets
    -->
    <ImportProjectExtensionTargets Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionTargets>
    <ImportProjectExtensionTargets Condition="'$(ImportProjectExtensionTargets)' == ''">true</ImportProjectExtensionTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.targets" Condition="'$(ImportProjectExtensionTargets)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />-->
  <PropertyGroup xmlns="">
    <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
  </PropertyGroup>
  <!--
      Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
      they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''" xmlns="">
    <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
    <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildTargets)" Condition="'$(CustomBeforeDirectoryBuildTargets)' != ''" />-->
  <!--<Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')" />-->
  <!--<Import Project="$(CustomAfterDirectoryBuildTargets)" Condition="'$(CustomAfterDirectoryBuildTargets)' != ''" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')" />-->
  <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute" xmlns="">
    <PropertyGroup>
      <TargetFrameworkMonikerAssemblyAttributeText Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">
// &lt;autogenerated /&gt;
using System%3b
using System.Reflection%3b
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute("$(TargetFrameworkMoniker)", FrameworkDisplayName = "$(TargetFrameworkMonikerDisplayName)")]
        </TargetFrameworkMonikerAssemblyAttributeText>
    </PropertyGroup>
  </Target>
  <PropertyGroup xmlns="">
    <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
    <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
           want that switch to be passed to the compiler so that either we or the user
           provides the references
           NoStdLib on the other hand indicates that the user doesn't want standard references
           so only if NoStdLib isn't set to true, will we provide the standard references
      -->
    <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
    <ErrorEndLocation Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(ErrorEndLocation)' == ''">true</ErrorEndLocation>
    <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
    <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
  </PropertyGroup>
  <!-- Add any "automatic" compiler references that need to be resolved when NoCompilerStandardLib is set
         but the user hasn't told us to not include standard references -->
  <ItemGroup Condition=" '$(NoCompilerStandardLib)' == 'true' and '$(NoStdLib)' != 'true' " xmlns="">
    <!-- Note that unlike VB, C# does not automatically locate System.dll as a "standard library"
           instead the reference is always passed from the project. Also, for mscorlib.dll
           we need to provide the explicit location in order to avoid resolving from, e.g.,
           {CandidateAssemblyFiles}.
      -->
    <_ExplicitReference Include="$(FrameworkPathOverride)\mscorlib.dll" />
  </ItemGroup>
  <!--<Import Project="$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets" Condition="'$(MSBuildRuntimeType)' == 'Full' and exists('$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets')" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCSharpTargets)" Condition="'$(CustomAfterMicrosoftCSharpTargets)' != '' and Exists('$(CustomAfterMicrosoftCSharpTargets)')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets">

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.Managed.After.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported after the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
  <PropertyGroup xmlns="">
    <InnerBuildProperty>TargetFramework</InnerBuildProperty>
    <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'" xmlns="">
    <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'" xmlns="">
    <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
        Detect WPF, and exclude the generated project from static graph isolation constraint checking.
        Escape the item to avoid eager evaluation of the wildcards.
    -->
    <GraphIsolationExemptReference Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''" Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
  </ItemGroup>
  <!--
      Properties for extension of ProjectReferenceTargets.
      Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
  -->
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'" xmlns="">
    <!-- Empty case is for builds which do not import the target files that set BuildProjectReferences -->
    <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
    <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
    <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
    <ProjectReferenceTargetsForPublish>GetTargetFrameworks;$(_MainReferenceTargetForPublish);GetNativeManifest;GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
    <!-- When DeployOnBuild=true, the Publish target is hooked to the Build target -->
    <ProjectReferenceTargetsForBuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForBuild>
    <ProjectReferenceTargetsForRebuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForRebuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForRebuild>
    <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'" xmlns="">
    <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'" xmlns="">
    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
    <!--
     Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
     This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
     -->
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
    <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
    <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files\dotnet\sdk\9.0.200\Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\blazego\source\repos\2labRSA\2labRSA.csproj
============================================================================================================================================
-->
</Project>